<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CudaSolve</name>
    </assembly>
    <members>
        <member name="T:ManagedCuda.CudaSolve.CsrQrInfo">
            <summary>
            opaque structure for QR factorization
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CsrQrInfo.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CsrQrInfo.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CsrQrInfo.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CsrQrInfo.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSolve.CsrQrInfo.Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.CudaSolveDense">
            <summary>
            CudaSolveDense: The cuSolverDN library was designed to solve dense linear systems of the form Ax=B
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.#ctor">
            <summary>
            Create new dense solve instance
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.#ctor(ManagedCuda.CudaStream)">
            <summary>
            Create new dense solve instance using stream stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.SetStream(ManagedCuda.CudaStream)">
            <summary>
            This function sets the stream to be used by the cuSolverDN library to execute its routines.
            </summary>
            <param name="stream">the stream to be used by the library.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GetStream">
            <summary>
            This function gets the stream to be used by the cuSolverDN library to execute its routines.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.PotrfBufferSize(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.PotrfBufferSize(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.PotrfBufferSize(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.PotrfBufferSize(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Potrf(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of Workspace</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo
            = -i, the i-th parameter is wrong. if devInfo = i, the leading minor of order i is not positive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Potrf(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of Workspace</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo
            = -i, the i-th parameter is wrong. if devInfo = i, the leading minor of order i is not positive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Potrf(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of Workspace</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo
            = -i, the i-th parameter is wrong. if devInfo = i, the leading minor of order i is not positive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Potrf(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of Workspace</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo
            = -i, the i-th parameter is wrong. if devInfo = i, the leading minor of order i is not positive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Potrs(ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function solves a system of linear equations A*X=B where A is a n×n Hermitian matrix, only lower or upper part is meaningful.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of columns of matrix X and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n). A is either
            lower cholesky factor L or upper Cholesky factor U.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb * nrhs. ldb is not less than max(1,n). As an input, B is right hand side matrix. As an
            output, B is the solution matrix.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo =
            -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Potrs(ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function solves a system of linear equations A*X=B where A is a n×n Hermitian matrix, only lower or upper part is meaningful.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of columns of matrix X and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n). A is either
            lower cholesky factor L or upper Cholesky factor U.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb * nrhs. ldb is not less than max(1,n). As an input, B is right hand side matrix. As an
            output, B is the solution matrix.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo =
            -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Potrs(ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function solves a system of linear equations A*X=B where A is a n×n Hermitian matrix, only lower or upper part is meaningful.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of columns of matrix X and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n). A is either
            lower cholesky factor L or upper Cholesky factor U.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb * nrhs. ldb is not less than max(1,n). As an input, B is right hand side matrix. As an
            output, B is the solution matrix.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo =
            -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Potrs(ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function solves a system of linear equations A*X=B where A is a n×n Hermitian matrix, only lower or upper part is meaningful.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of columns of matrix X and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n). A is either
            lower cholesky factor L or upper Cholesky factor U.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb * nrhs. ldb is not less than max(1,n). As an input, B is right hand side matrix. As an
            output, B is the solution matrix.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo =
            -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GetrfBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GetrfBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GetrfBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GetrfBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Getrf(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="devIpiv">array of size at least min(m,n), containing pivot indices.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is
            successful. if devInfo = -i, the i-th parameter is wrong. if devInfo = i, the U(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Getrf(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="devIpiv">array of size at least min(m,n), containing pivot indices.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is
            successful. if devInfo = -i, the i-th parameter is wrong. if devInfo = i, the U(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Getrf(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="devIpiv">array of size at least min(m,n), containing pivot indices.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is
            successful. if devInfo = -i, the i-th parameter is wrong. if devInfo = i, the U(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Getrf(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="devIpiv">array of size at least min(m,n), containing pivot indices.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is
            successful. if devInfo = -i, the i-th parameter is wrong. if devInfo = i, the U(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Getrs(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function solves a linear system of multiple right-hand sides op(A)*X=B.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of right-hand sides.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="devIpiv">array of size at least n, containing pivot indices.</param>
            <param name="B">array of dimension ldb * nrhs with ldb is not less than max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Getrs(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function solves a linear system of multiple right-hand sides op(A)*X=B.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of right-hand sides.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="devIpiv">array of size at least n, containing pivot indices.</param>
            <param name="B">array of dimension ldb * nrhs with ldb is not less than max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Getrs(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function solves a linear system of multiple right-hand sides op(A)*X=B.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of right-hand sides.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="devIpiv">array of size at least n, containing pivot indices.</param>
            <param name="B">array of dimension ldb * nrhs with ldb is not less than max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Getrs(ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function solves a linear system of multiple right-hand sides op(A)*X=B.
            </summary>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of right-hand sides.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="devIpiv">array of size at least n, containing pivot indices.</param>
            <param name="B">array of dimension ldb * nrhs with ldb is not less than max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Geqrf(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="TAU">array of dimension at least min(m,n).</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of working array Workspace.</param>
            <param name="devInfo">if info = 0, the LU factorization is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Geqrf(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="TAU">array of dimension at least min(m,n).</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of working array Workspace.</param>
            <param name="devInfo">if info = 0, the LU factorization is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Geqrf(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="TAU">array of dimension at least min(m,n).</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of working array Workspace.</param>
            <param name="devInfo">if info = 0, the LU factorization is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Geqrf(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="TAU">array of dimension at least min(m,n).</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of working array Workspace.</param>
            <param name="devInfo">if info = 0, the LU factorization is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Ormqr(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n). The vector tau is from geqrf,
            so tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="devInfo">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Ormqr(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n). The vector tau is from geqrf,
            so tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="devInfo">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Unmqr(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n). The vector tau is from geqrf,
            so tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="devInfo">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Unmqr(ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n). The vector tau is from geqrf,
            so tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="devInfo">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GeqrfBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GeqrfBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GeqrfBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GeqrfBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Gebrd(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="D">array of dimension min(m,n). The diagonal elements of the bidiagonal
            matrix B: D(i) = A(i,i).</param>
            <param name="E">array of dimension min(m,n). The off-diagonal elements of the bidiagonal
            matrix B: if m&gt;=n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m&lt;n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</param>
            <param name="TAUQ">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix Q.</param>
            <param name="TAUP">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix P.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Gebrd(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="D">array of dimension min(m,n). The diagonal elements of the bidiagonal
            matrix B: D(i) = A(i,i).</param>
            <param name="E">array of dimension min(m,n). The off-diagonal elements of the bidiagonal
            matrix B: if m&gt;=n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m&lt;n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</param>
            <param name="TAUQ">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix Q.</param>
            <param name="TAUP">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix P.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Gebrd(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="D">array of dimension min(m,n). The diagonal elements of the bidiagonal
            matrix B: D(i) = A(i,i).</param>
            <param name="E">array of dimension min(m,n). The off-diagonal elements of the bidiagonal
            matrix B: if m&gt;=n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m&lt;n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</param>
            <param name="TAUQ">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix Q.</param>
            <param name="TAUP">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix P.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Gebrd(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="D">array of dimension min(m,n). The diagonal elements of the bidiagonal
            matrix B: D(i) = A(i,i).</param>
            <param name="E">array of dimension min(m,n). The off-diagonal elements of the bidiagonal
            matrix B: if m&gt;=n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m&lt;n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</param>
            <param name="TAUQ">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix Q.</param>
            <param name="TAUP">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix P.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GebrdBufferSizeFloat(System.Int32,System.Int32)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GebrdBufferSizeDouble(System.Int32,System.Int32)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GebrdBufferSizeFloatComplex(System.Int32,System.Int32)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GebrdBufferSizeDoubleComplex(System.Int32,System.Int32)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GesvdBufferSizeFloat(System.Int32,System.Int32)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GesvdBufferSizeDouble(System.Int32,System.Int32)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GesvdBufferSizeFloatComplex(System.Int32,System.Int32)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.GesvdBufferSizeDoubleComplex(System.Int32,System.Int32)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Gesvd(System.Char,System.Char,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="jobu">specifies options for computing all or part of the matrix U: = 'A': all m columns of
            U are returned in array U: = 'S': the first min(m,n) columns of U (the left singular
            vectors) are returned in the array U; = 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on
            the array A; = 'N': no columns of U (no left singular vectors) are computed.</param>
            <param name="jobvt">specifies options for computing all or part of the matrix V**T: = 'A': all N rows
            of V**T are returned in the array VT; = 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the
            array VT; = 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = 'N': no rows
            of V**T (no right singular vectors) are computed.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m). On exit,
            the contents of A are destroyed.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="S">array of dimension min(m,n). The singular values of A, sorted so that S(i)
            &gt;= S(i+1).</param>
            <param name="U">array of dimension ldu * m with ldu is not less than max(1,m). U contains
            the m×m unitary matrix U.</param>
            <param name="ldu">leading dimension of two-dimensional array used to store matrix U.</param>
            <param name="VT">array of dimension ldvt * n with ldvt is not less than max(1,n). VT
            contains the n×n unitary matrix V**T.</param>
            <param name="ldvt">leading dimension of two-dimensional array used to store matrix Vt.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
            <param name="rwork"></param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the ith
            parameter is wrong. if devInfo &gt; 0, devInfo indicates how many superdiagonals of an intermediate
            bidiagonal form B did not converge to zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Gesvd(System.Char,System.Char,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="jobu">specifies options for computing all or part of the matrix U: = 'A': all m columns of
            U are returned in array U: = 'S': the first min(m,n) columns of U (the left singular
            vectors) are returned in the array U; = 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on
            the array A; = 'N': no columns of U (no left singular vectors) are computed.</param>
            <param name="jobvt">specifies options for computing all or part of the matrix V**T: = 'A': all N rows
            of V**T are returned in the array VT; = 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the
            array VT; = 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = 'N': no rows
            of V**T (no right singular vectors) are computed.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m). On exit,
            the contents of A are destroyed.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="S">array of dimension min(m,n). The singular values of A, sorted so that S(i)
            &gt;= S(i+1).</param>
            <param name="U">array of dimension ldu * m with ldu is not less than max(1,m). U contains
            the m×m unitary matrix U.</param>
            <param name="ldu">leading dimension of two-dimensional array used to store matrix U.</param>
            <param name="VT">array of dimension ldvt * n with ldvt is not less than max(1,n). VT
            contains the n×n unitary matrix V**T.</param>
            <param name="ldvt">leading dimension of two-dimensional array used to store matrix Vt.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
            <param name="rwork"></param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the ith
            parameter is wrong. if devInfo &gt; 0, devInfo indicates how many superdiagonals of an intermediate
            bidiagonal form B did not converge to zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Gesvd(System.Char,System.Char,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="jobu">specifies options for computing all or part of the matrix U: = 'A': all m columns of
            U are returned in array U: = 'S': the first min(m,n) columns of U (the left singular
            vectors) are returned in the array U; = 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on
            the array A; = 'N': no columns of U (no left singular vectors) are computed.</param>
            <param name="jobvt">specifies options for computing all or part of the matrix V**T: = 'A': all N rows
            of V**T are returned in the array VT; = 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the
            array VT; = 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = 'N': no rows
            of V**T (no right singular vectors) are computed.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m). On exit,
            the contents of A are destroyed.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="S">array of dimension min(m,n). The singular values of A, sorted so that S(i)
            &gt;= S(i+1).</param>
            <param name="U">array of dimension ldu * m with ldu is not less than max(1,m). U contains
            the m×m unitary matrix U.</param>
            <param name="ldu">leading dimension of two-dimensional array used to store matrix U.</param>
            <param name="VT">array of dimension ldvt * n with ldvt is not less than max(1,n). VT
            contains the n×n unitary matrix V**T.</param>
            <param name="ldvt">leading dimension of two-dimensional array used to store matrix Vt.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
            <param name="rwork"></param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the ith
            parameter is wrong. if devInfo &gt; 0, devInfo indicates how many superdiagonals of an intermediate
            bidiagonal form B did not converge to zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Gesvd(System.Char,System.Char,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="jobu">specifies options for computing all or part of the matrix U: = 'A': all m columns of
            U are returned in array U: = 'S': the first min(m,n) columns of U (the left singular
            vectors) are returned in the array U; = 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on
            the array A; = 'N': no columns of U (no left singular vectors) are computed.</param>
            <param name="jobvt">specifies options for computing all or part of the matrix V**T: = 'A': all N rows
            of V**T are returned in the array VT; = 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the
            array VT; = 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = 'N': no rows
            of V**T (no right singular vectors) are computed.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m). On exit,
            the contents of A are destroyed.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="S">array of dimension min(m,n). The singular values of A, sorted so that S(i)
            &gt;= S(i+1).</param>
            <param name="U">array of dimension ldu * m with ldu is not less than max(1,m). U contains
            the m×m unitary matrix U.</param>
            <param name="ldu">leading dimension of two-dimensional array used to store matrix U.</param>
            <param name="VT">array of dimension ldvt * n with ldvt is not less than max(1,n). VT
            contains the n×n unitary matrix V**T.</param>
            <param name="ldvt">leading dimension of two-dimensional array used to store matrix Vt.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
            <param name="rwork"></param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the ith
            parameter is wrong. if devInfo &gt; 0, devInfo indicates how many superdiagonals of an intermediate
            bidiagonal form B did not converge to zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Sytrf(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="ipiv">array of size at least n, containing pivot indices.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working space work.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i, the D(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Sytrf(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="ipiv">array of size at least n, containing pivot indices.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working space work.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i, the D(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Sytrf(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="ipiv">array of size at least n, containing pivot indices.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working space work.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i, the D(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.Sytrf(ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="ipiv">array of size at least n, containing pivot indices.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working space work.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i, the D(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.SytrfBufferSize(System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.SytrfBufferSize(System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.SytrfBufferSize(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveDense.SytrfBufferSize(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <returns>size of Workspace</returns>
        </member>
        <member name="T:ManagedCuda.CudaSolve.CudaSolveException">
            <summary>
            An CudaSolveException is thrown, if any wrapped call to the CuSolve-library does not return <see cref="F:ManagedCuda.CudaSolve.cusolverStatus.Success"/>.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="serInfo"></param>
            <param name="streamingContext"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveException.#ctor(ManagedCuda.CudaSolve.cusolverStatus)">
            <summary>
            
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveException.#ctor(ManagedCuda.CudaSolve.cusolverStatus,System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="error"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveException.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:ManagedCuda.CudaSolve.CudaSolveException.SolverStatus">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.CudaSolveNativeMethods">
            <summary/>
        </member>
        <member name="T:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense">
            <summary>
            The cuSolverDN library was designed to solve dense linear systems of the form Ax=B
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCreate(ManagedCuda.CudaSolve.cusolverDnHandle@)">
            <summary>
            This function initializes the cuSolverDN library and creates a handle on the cuSolverDN
            context. It must be called before any other cuSolverDN API function is invoked. It
            allocates hardware resources necessary for accessing the GPU
            </summary>
            <param name="handle">the pointer to the handle to the cuSolverDN context.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDestroy(ManagedCuda.CudaSolve.cusolverDnHandle)">
            <summary>
            This function releases CPU-side resources used by the cuSolverDN library.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSetStream(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            This function sets the stream to be used by the cuSolverDN library to execute its routines.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="streamId">the stream to be used by the library.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnGetStream(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.BasicTypes.CUstream@)">
            <summary>
            This function sets the stream to be used by the cuSolverDN library to execute its routines.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="sreamId">the stream to be used by the library.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSpotrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of Workspace</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDpotrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of Workspace</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCpotrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of Workspace</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZpotrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of Workspace</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSpotrf(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of Workspace</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo
            = -i, the i-th parameter is wrong. if devInfo = i, the leading minor of order i is not positive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDpotrf(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of Workspace</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo
            = -i, the i-th parameter is wrong. if devInfo = i, the leading minor of order i is not positive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCpotrf(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of Workspace</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo
            = -i, the i-th parameter is wrong. if devInfo = i, the leading minor of order i is not positive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZpotrf(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the Cholesky factorization of a Hermitian positive-definite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of Workspace</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo
            = -i, the i-th parameter is wrong. if devInfo = i, the leading minor of order i is not positive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSpotrs(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves a system of linear equations A*X=B where A is a n×n Hermitian matrix, only lower or upper part is meaningful.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of columns of matrix X and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n). A is either
            lower cholesky factor L or upper Cholesky factor U.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb * nrhs. ldb is not less than max(1,n). As an input, B is right hand side matrix. As an
            output, B is the solution matrix.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo =
            -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDpotrs(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves a system of linear equations A*X=B where A is a n×n Hermitian matrix, only lower or upper part is meaningful.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of columns of matrix X and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n). A is either
            lower cholesky factor L or upper Cholesky factor U.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb * nrhs. ldb is not less than max(1,n). As an input, B is right hand side matrix. As an
            output, B is the solution matrix.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo =
            -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCpotrs(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves a system of linear equations A*X=B where A is a n×n Hermitian matrix, only lower or upper part is meaningful.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of columns of matrix X and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n). A is either
            lower cholesky factor L or upper Cholesky factor U.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb * nrhs. ldb is not less than max(1,n). As an input, B is right hand side matrix. As an
            output, B is the solution matrix.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo =
            -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZpotrs(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves a system of linear equations A*X=B where A is a n×n Hermitian matrix, only lower or upper part is meaningful.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of columns of matrix X and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n). A is either
            lower cholesky factor L or upper Cholesky factor U.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="B">array of dimension ldb * nrhs. ldb is not less than max(1,n). As an input, B is right hand side matrix. As an
            output, B is the solution matrix.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the Cholesky factorization is successful. if devInfo =
            -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgetrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of Workspace</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgetrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of Workspace</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgetrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of Workspace</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgetrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of Workspace</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgetrf(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="devIpiv">array of size at least min(m,n), containing pivot indices.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is
            successful. if devInfo = -i, the i-th parameter is wrong. if devInfo = i, the U(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgetrf(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="devIpiv">array of size at least min(m,n), containing pivot indices.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is
            successful. if devInfo = -i, the i-th parameter is wrong. if devInfo = i, the U(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgetrf(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="devIpiv">array of size at least min(m,n), containing pivot indices.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is
            successful. if devInfo = -i, the i-th parameter is wrong. if devInfo = i, the U(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgetrf(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the LU factorization of a m×n matrix P*A=L*U
            where A is a m×n matrix, P is a permutation matrix, L is a lower triangular matrix with
            unit diagonal, and U is an upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="devIpiv">array of size at least min(m,n), containing pivot indices.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is
            successful. if devInfo = -i, the i-th parameter is wrong. if devInfo = i, the U(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSlaswp(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDlaswp(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnClaswp(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZlaswp(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgetrs(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves a linear system of multiple right-hand sides op(A)*X=B.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of right-hand sides.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="devIpiv">array of size at least n, containing pivot indices.</param>
            <param name="B">array of dimension ldb * nrhs with ldb is not less than max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgetrs(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves a linear system of multiple right-hand sides op(A)*X=B.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of right-hand sides.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="devIpiv">array of size at least n, containing pivot indices.</param>
            <param name="B">array of dimension ldb * nrhs with ldb is not less than max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgetrs(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves a linear system of multiple right-hand sides op(A)*X=B.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of right-hand sides.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="devIpiv">array of size at least n, containing pivot indices.</param>
            <param name="B">array of dimension ldb * nrhs with ldb is not less than max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgetrs(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves a linear system of multiple right-hand sides op(A)*X=B.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="trans">operation op(A) that is non- or (conj.) transpose.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nrhs">number of right-hand sides.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="devIpiv">array of size at least n, containing pivot indices.</param>
            <param name="B">array of dimension ldb * nrhs with ldb is not less than max(1,n).</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgeqrf(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="TAU">array of dimension at least min(m,n).</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of working array Workspace.</param>
            <param name="devInfo">if info = 0, the LU factorization is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgeqrf(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="TAU">array of dimension at least min(m,n).</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of working array Workspace.</param>
            <param name="devInfo">if info = 0, the LU factorization is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgeqrf(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="TAU">array of dimension at least min(m,n).</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of working array Workspace.</param>
            <param name="devInfo">if info = 0, the LU factorization is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgeqrf(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="TAU">array of dimension at least min(m,n).</param>
            <param name="Workspace">working space, array of size Lwork.</param>
            <param name="Lwork">size of working array Workspace.</param>
            <param name="devInfo">if info = 0, the LU factorization is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSormqr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function overwrites m×n matrix C by 
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n). The vector tau is from geqrf,
            so tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="devInfo">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDormqr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function overwrites m×n matrix C by 
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n). The vector tau is from geqrf,
            so tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="devInfo">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCunmqr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function overwrites m×n matrix C by 
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n). The vector tau is from geqrf,
            so tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="devInfo">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZunmqr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function overwrites m×n matrix C by 
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n). The vector tau is from geqrf,
            so tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="devInfo">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgeqrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of working array Workspace.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgeqrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of working array Workspace.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgeqrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of working array Workspace.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgeqrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of working array Workspace.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSormqr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * k with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n).</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="lwork">size of working array Workspace.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDormqr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * k with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n).</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="lwork">size of working array Workspace.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCunmqr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * k with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n).</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="lwork">size of working array Workspace.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZunmqr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the QR factorization of a m×n matrix A=Q*R
            where A is a m×n matrix, Q is a m×n matrix, and R is a n×n upper triangular matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">indicates if matrix Q is on the left or right of C.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="k">number of elementary relfections.</param>
            <param name="A">array of dimension lda * k with lda is not less than max(1,m).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="tau">array of dimension at least min(m,n).</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C.</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="lwork">size of working array Workspace.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSorgqr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generate unitary matrix Q from QR factorization
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix Q. m >= 0;</param>
            <param name="n">number of columns of matrix Q. m >= n >= 0;</param>
            <param name="k">number of elementary relfections whose product defines the matrix Q. n >= k >= 0;</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).
            i-th column of A contains elementary reflection vector.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m).</param>
            <param name="tau">array of dimension k. tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDorgqr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generate unitary matrix Q from QR factorization
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix Q. m >= 0;</param>
            <param name="n">number of columns of matrix Q. m >= n >= 0;</param>
            <param name="k">number of elementary relfections whose product defines the matrix Q. n >= k >= 0;</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).
            i-th column of A contains elementary reflection vector.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m).</param>
            <param name="tau">array of dimension k. tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCungqr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generate unitary matrix Q from QR factorization
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix Q. m >= 0;</param>
            <param name="n">number of columns of matrix Q. m >= n >= 0;</param>
            <param name="k">number of elementary relfections whose product defines the matrix Q. n >= k >= 0;</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).
            i-th column of A contains elementary reflection vector.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m).</param>
            <param name="tau">array of dimension k. tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZungqr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generate unitary matrix Q from QR factorization
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix Q. m >= 0;</param>
            <param name="n">number of columns of matrix Q. m >= n >= 0;</param>
            <param name="k">number of elementary relfections whose product defines the matrix Q. n >= k >= 0;</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).
            i-th column of A contains elementary reflection vector.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m).</param>
            <param name="tau">array of dimension k. tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSorgqr(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generate unitary matrix Q from QR factorization
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix Q. m >= 0;</param>
            <param name="n">number of columns of matrix Q. m >= n >= 0;</param>
            <param name="k">number of elementary relfections whose product defines the matrix Q. n >= k >= 0;</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).
            i-th column of A contains elementary reflection vector.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m).</param>
            <param name="tau">array of dimension k. tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="work">working space, rray of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the orgqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDorgqr(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generate unitary matrix Q from QR factorization
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix Q. m >= 0;</param>
            <param name="n">number of columns of matrix Q. m >= n >= 0;</param>
            <param name="k">number of elementary relfections whose product defines the matrix Q. n >= k >= 0;</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).
            i-th column of A contains elementary reflection vector.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m).</param>
            <param name="tau">array of dimension k. tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="work">working space, rray of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the orgqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCungqr(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generate unitary matrix Q from QR factorization
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix Q. m >= 0;</param>
            <param name="n">number of columns of matrix Q. m >= n >= 0;</param>
            <param name="k">number of elementary relfections whose product defines the matrix Q. n >= k >= 0;</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).
            i-th column of A contains elementary reflection vector.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m).</param>
            <param name="tau">array of dimension k. tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="work">working space, rray of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the orgqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZungqr(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generate unitary matrix Q from QR factorization
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix Q. m >= 0;</param>
            <param name="n">number of columns of matrix Q. m >= n >= 0;</param>
            <param name="k">number of elementary relfections whose product defines the matrix Q. n >= k >= 0;</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m).
            i-th column of A contains elementary reflection vector.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m).</param>
            <param name="tau">array of dimension k. tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="work">working space, rray of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the orgqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgebrd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="D">array of dimension min(m,n). The diagonal elements of the bidiagonal
            matrix B: D(i) = A(i,i).</param>
            <param name="E">array of dimension min(m,n). The off-diagonal elements of the bidiagonal
            matrix B: if m&gt;=n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m&lt;n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</param>
            <param name="TAUQ">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix Q.</param>
            <param name="TAUP">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix P.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgebrd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="D">array of dimension min(m,n). The diagonal elements of the bidiagonal
            matrix B: D(i) = A(i,i).</param>
            <param name="E">array of dimension min(m,n). The off-diagonal elements of the bidiagonal
            matrix B: if m&gt;=n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m&lt;n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</param>
            <param name="TAUQ">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix Q.</param>
            <param name="TAUP">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix P.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgebrd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="D">array of dimension min(m,n). The diagonal elements of the bidiagonal
            matrix B: D(i) = A(i,i).</param>
            <param name="E">array of dimension min(m,n). The off-diagonal elements of the bidiagonal
            matrix B: if m&gt;=n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m&lt;n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</param>
            <param name="TAUQ">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix Q.</param>
            <param name="TAUP">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix P.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgebrd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="D">array of dimension min(m,n). The diagonal elements of the bidiagonal
            matrix B: D(i) = A(i,i).</param>
            <param name="E">array of dimension min(m,n). The off-diagonal elements of the bidiagonal
            matrix B: if m&gt;=n, E(i) = A(i,i+1) for i = 1,2,...,n-1; if m&lt;n, E(i) = A(i+1,i) for i = 1,2,...,m-1.</param>
            <param name="TAUQ">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix Q.</param>
            <param name="TAUP">array of dimension min(m,n). The scalar factors of the elementary reflectors
            which represent the orthogonal matrix P.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSsytrd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDsytrd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSsytrd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Char,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDsytrd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Char,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnChetrd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZhetrd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnChetrd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZhetrd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgebrd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgebrd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgebrd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgebrd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function reduces a general real m×n matrix A to upper or lower bidiagonal form B by
            an orthogonal transformation: Q^H*A*P=B
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="Lwork">size of Work, returned by gebrd_bufferSize.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgesvd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgesvd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgesvd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgesvd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSgesvd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Char,System.Char,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobu">specifies options for computing all or part of the matrix U: = 'A': all m columns of
            U are returned in array U: = 'S': the first min(m,n) columns of U (the left singular
            vectors) are returned in the array U; = 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on
            the array A; = 'N': no columns of U (no left singular vectors) are computed.</param>
            <param name="jobvt">specifies options for computing all or part of the matrix V**T: = 'A': all N rows
            of V**T are returned in the array VT; = 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the
            array VT; = 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = 'N': no rows
            of V**T (no right singular vectors) are computed.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m). On exit,
            the contents of A are destroyed.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="S">array of dimension min(m,n). The singular values of A, sorted so that S(i)
            &gt;= S(i+1).</param>
            <param name="U">array of dimension ldu * m with ldu is not less than max(1,m). U contains
            the m×m unitary matrix U.</param>
            <param name="ldu">leading dimension of two-dimensional array used to store matrix U.</param>
            <param name="VT">array of dimension ldvt * n with ldvt is not less than max(1,n). VT
            contains the n×n unitary matrix V**T.</param>
            <param name="ldvt">leading dimension of two-dimensional array used to store matrix Vt.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
            <param name="rwork"></param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the ith
            parameter is wrong. if devInfo &gt; 0, devInfo indicates how many superdiagonals of an intermediate
            bidiagonal form B did not converge to zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDgesvd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Char,System.Char,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobu">specifies options for computing all or part of the matrix U: = 'A': all m columns of
            U are returned in array U: = 'S': the first min(m,n) columns of U (the left singular
            vectors) are returned in the array U; = 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on
            the array A; = 'N': no columns of U (no left singular vectors) are computed.</param>
            <param name="jobvt">specifies options for computing all or part of the matrix V**T: = 'A': all N rows
            of V**T are returned in the array VT; = 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the
            array VT; = 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = 'N': no rows
            of V**T (no right singular vectors) are computed.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m). On exit,
            the contents of A are destroyed.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="S">array of dimension min(m,n). The singular values of A, sorted so that S(i)
            &gt;= S(i+1).</param>
            <param name="U">array of dimension ldu * m with ldu is not less than max(1,m). U contains
            the m×m unitary matrix U.</param>
            <param name="ldu">leading dimension of two-dimensional array used to store matrix U.</param>
            <param name="VT">array of dimension ldvt * n with ldvt is not less than max(1,n). VT
            contains the n×n unitary matrix V**T.</param>
            <param name="ldvt">leading dimension of two-dimensional array used to store matrix Vt.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
            <param name="rwork"></param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the ith
            parameter is wrong. if devInfo &gt; 0, devInfo indicates how many superdiagonals of an intermediate
            bidiagonal form B did not converge to zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCgesvd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Char,System.Char,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobu">specifies options for computing all or part of the matrix U: = 'A': all m columns of
            U are returned in array U: = 'S': the first min(m,n) columns of U (the left singular
            vectors) are returned in the array U; = 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on
            the array A; = 'N': no columns of U (no left singular vectors) are computed.</param>
            <param name="jobvt">specifies options for computing all or part of the matrix V**T: = 'A': all N rows
            of V**T are returned in the array VT; = 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the
            array VT; = 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = 'N': no rows
            of V**T (no right singular vectors) are computed.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m). On exit,
            the contents of A are destroyed.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="S">array of dimension min(m,n). The singular values of A, sorted so that S(i)
            &gt;= S(i+1).</param>
            <param name="U">array of dimension ldu * m with ldu is not less than max(1,m). U contains
            the m×m unitary matrix U.</param>
            <param name="ldu">leading dimension of two-dimensional array used to store matrix U.</param>
            <param name="VT">array of dimension ldvt * n with ldvt is not less than max(1,n). VT
            contains the n×n unitary matrix V**T.</param>
            <param name="ldvt">leading dimension of two-dimensional array used to store matrix Vt.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
            <param name="rwork"></param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the ith
            parameter is wrong. if devInfo &gt; 0, devInfo indicates how many superdiagonals of an intermediate
            bidiagonal form B did not converge to zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZgesvd(ManagedCuda.CudaSolve.cusolverDnHandle,System.Char,System.Char,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the singular value decomposition (SVD) of a m×n matrix A and
            corresponding the left and/or right singular vectors.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobu">specifies options for computing all or part of the matrix U: = 'A': all m columns of
            U are returned in array U: = 'S': the first min(m,n) columns of U (the left singular
            vectors) are returned in the array U; = 'O': the first min(m,n) columns of U (the left singular vectors) are overwritten on
            the array A; = 'N': no columns of U (no left singular vectors) are computed.</param>
            <param name="jobvt">specifies options for computing all or part of the matrix V**T: = 'A': all N rows
            of V**T are returned in the array VT; = 'S': the first min(m,n) rows of V**T (the right singular vectors) are returned in the
            array VT; = 'O': the first min(m,n) rows of V**T (the right singular vectors) are overwritten on the array A; = 'N': no rows
            of V**T (no right singular vectors) are computed.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,m). On exit,
            the contents of A are destroyed.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="S">array of dimension min(m,n). The singular values of A, sorted so that S(i)
            &gt;= S(i+1).</param>
            <param name="U">array of dimension ldu * m with ldu is not less than max(1,m). U contains
            the m×m unitary matrix U.</param>
            <param name="ldu">leading dimension of two-dimensional array used to store matrix U.</param>
            <param name="VT">array of dimension ldvt * n with ldvt is not less than max(1,n). VT
            contains the n×n unitary matrix V**T.</param>
            <param name="ldvt">leading dimension of two-dimensional array used to store matrix Vt.</param>
            <param name="Work">working space, array of size Lwork.</param>
            <param name="Lwork">size of Work, returned by gesvd_bufferSize.</param>
            <param name="rwork"></param>
            <param name="devInfo">if devInfo = 0, the operation is successful. if devInfo = -i, the ith
            parameter is wrong. if devInfo &gt; 0, devInfo indicates how many superdiagonals of an intermediate
            bidiagonal form B did not converge to zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSsytrf(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="ipiv">array of size at least n, containing pivot indices.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working space work.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i, the D(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDsytrf(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="ipiv">array of size at least n, containing pivot indices.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working space work.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i, the D(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCsytrf(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="ipiv">array of size at least n, containing pivot indices.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working space work.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i, the D(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZsytrf(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">indicates if matrix A lower or upper part is stored, the other part is not referenced.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="ipiv">array of size at least n, containing pivot indices.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working space work.</param>
            <param name="devInfo">if devInfo = 0, the LU factorization is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i, the D(i,i) = 0.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSsytrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of working space work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDsytrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of working space work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCsytrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of working space work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZsytrf_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function computes the Bunch-Kaufman factorization of a n×n symmetric indefinite matrix.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A.</param>
            <param name="Lwork">size of working space work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSorgbr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generates one of the unitary matrices Q or P**T determined by GEBRD
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">if side = CUBLAS_SIDE_LEFT, generate Q. if side = CUBLAS_SIDE_RIGHT, generate P**T.</param>
            <param name="m">number of rows of matrix Q or P**T.</param>
            <param name="n">if side = CUBLAS_SIDE_LEFT, m>= n>= min(m,k). if side = CUBLAS_SIDE_RIGHT, n>= m>= min(n,k).</param>
            <param name="k">if side = CUBLAS_SIDE_LEFT, the number of columns in the original mby-
            k matrix reduced by gebrd. if side = CUBLAS_SIDE_RIGHT, the number of rows in the original k-by-n matrix reduced by gebrd.</param>
            <param name="A">array of dimension lda * n On entry, the vectors which define the
            elementary reflectors, as returned by gebrd. On exit, the m-by-n matrix Q or P**T.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m);</param>
            <param name="tau">array of dimension min(m,k) if side is CUBLAS_SIDE_LEFT; of dimension min(n,k) if side is
            CUBLAS_SIDE_RIGHT; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q
            or P**T, as returned by gebrd in its array argument TAUQ or TAUP.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDorgbr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generates one of the unitary matrices Q or P**T determined by GEBRD
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">if side = CUBLAS_SIDE_LEFT, generate Q. if side = CUBLAS_SIDE_RIGHT, generate P**T.</param>
            <param name="m">number of rows of matrix Q or P**T.</param>
            <param name="n">if side = CUBLAS_SIDE_LEFT, m>= n>= min(m,k). if side = CUBLAS_SIDE_RIGHT, n>= m>= min(n,k).</param>
            <param name="k">if side = CUBLAS_SIDE_LEFT, the number of columns in the original mby-
            k matrix reduced by gebrd. if side = CUBLAS_SIDE_RIGHT, the number of rows in the original k-by-n matrix reduced by gebrd.</param>
            <param name="A">array of dimension lda * n On entry, the vectors which define the
            elementary reflectors, as returned by gebrd. On exit, the m-by-n matrix Q or P**T.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m);</param>
            <param name="tau">array of dimension min(m,k) if side is CUBLAS_SIDE_LEFT; of dimension min(n,k) if side is
            CUBLAS_SIDE_RIGHT; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q
            or P**T, as returned by gebrd in its array argument TAUQ or TAUP.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCungbr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generates one of the unitary matrices Q or P**T determined by GEBRD
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">if side = CUBLAS_SIDE_LEFT, generate Q. if side = CUBLAS_SIDE_RIGHT, generate P**T.</param>
            <param name="m">number of rows of matrix Q or P**T.</param>
            <param name="n">if side = CUBLAS_SIDE_LEFT, m>= n>= min(m,k). if side = CUBLAS_SIDE_RIGHT, n>= m>= min(n,k).</param>
            <param name="k">if side = CUBLAS_SIDE_LEFT, the number of columns in the original mby-
            k matrix reduced by gebrd. if side = CUBLAS_SIDE_RIGHT, the number of rows in the original k-by-n matrix reduced by gebrd.</param>
            <param name="A">array of dimension lda * n On entry, the vectors which define the
            elementary reflectors, as returned by gebrd. On exit, the m-by-n matrix Q or P**T.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m);</param>
            <param name="tau">array of dimension min(m,k) if side is CUBLAS_SIDE_LEFT; of dimension min(n,k) if side is
            CUBLAS_SIDE_RIGHT; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q
            or P**T, as returned by gebrd in its array argument TAUQ or TAUP.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZungbr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generates one of the unitary matrices Q or P**T determined by GEBRD
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">if side = CUBLAS_SIDE_LEFT, generate Q. if side = CUBLAS_SIDE_RIGHT, generate P**T.</param>
            <param name="m">number of rows of matrix Q or P**T.</param>
            <param name="n">if side = CUBLAS_SIDE_LEFT, m>= n>= min(m,k). if side = CUBLAS_SIDE_RIGHT, n>= m>= min(n,k).</param>
            <param name="k">if side = CUBLAS_SIDE_LEFT, the number of columns in the original mby-
            k matrix reduced by gebrd. if side = CUBLAS_SIDE_RIGHT, the number of rows in the original k-by-n matrix reduced by gebrd.</param>
            <param name="A">array of dimension lda * n On entry, the vectors which define the
            elementary reflectors, as returned by gebrd. On exit, the m-by-n matrix Q or P**T.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m);</param>
            <param name="tau">array of dimension min(m,k) if side is CUBLAS_SIDE_LEFT; of dimension min(n,k) if side is
            CUBLAS_SIDE_RIGHT; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q
            or P**T, as returned by gebrd in its array argument TAUQ or TAUP.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSorgbr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generates one of the unitary matrices Q or P**T determined by GEBRD
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">if side = CUBLAS_SIDE_LEFT, generate Q. if side = CUBLAS_SIDE_RIGHT, generate P**T.</param>
            <param name="m">number of rows of matrix Q or P**T.</param>
            <param name="n">if side = CUBLAS_SIDE_LEFT, m>= n>= min(m,k). if side = CUBLAS_SIDE_RIGHT, n>= m>= min(n,k).</param>
            <param name="k">if side = CUBLAS_SIDE_LEFT, the number of columns in the original mby-
            k matrix reduced by gebrd. if side = CUBLAS_SIDE_RIGHT, the number of rows in the original k-by-n matrix reduced by gebrd.</param>
            <param name="A">array of dimension lda * n On entry, the vectors which define the
            elementary reflectors, as returned by gebrd. On exit, the m-by-n matrix Q or P**T.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m);</param>
            <param name="tau">array of dimension min(m,k) if side is CUBLAS_SIDE_LEFT; of dimension min(n,k) if side is
            CUBLAS_SIDE_RIGHT; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q
            or P**T, as returned by gebrd in its array argument TAUQ or TAUP.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
            <param name="work">working space, array of size lwork.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDorgbr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generates one of the unitary matrices Q or P**T determined by GEBRD
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">if side = CUBLAS_SIDE_LEFT, generate Q. if side = CUBLAS_SIDE_RIGHT, generate P**T.</param>
            <param name="m">number of rows of matrix Q or P**T.</param>
            <param name="n">if side = CUBLAS_SIDE_LEFT, m>= n>= min(m,k). if side = CUBLAS_SIDE_RIGHT, n>= m>= min(n,k).</param>
            <param name="k">if side = CUBLAS_SIDE_LEFT, the number of columns in the original mby-
            k matrix reduced by gebrd. if side = CUBLAS_SIDE_RIGHT, the number of rows in the original k-by-n matrix reduced by gebrd.</param>
            <param name="A">array of dimension lda * n On entry, the vectors which define the
            elementary reflectors, as returned by gebrd. On exit, the m-by-n matrix Q or P**T.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m);</param>
            <param name="tau">array of dimension min(m,k) if side is CUBLAS_SIDE_LEFT; of dimension min(n,k) if side is
            CUBLAS_SIDE_RIGHT; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q
            or P**T, as returned by gebrd in its array argument TAUQ or TAUP.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
            <param name="work">working space, array of size lwork.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCungbr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generates one of the unitary matrices Q or P**T determined by GEBRD
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">if side = CUBLAS_SIDE_LEFT, generate Q. if side = CUBLAS_SIDE_RIGHT, generate P**T.</param>
            <param name="m">number of rows of matrix Q or P**T.</param>
            <param name="n">if side = CUBLAS_SIDE_LEFT, m>= n>= min(m,k). if side = CUBLAS_SIDE_RIGHT, n>= m>= min(n,k).</param>
            <param name="k">if side = CUBLAS_SIDE_LEFT, the number of columns in the original mby-
            k matrix reduced by gebrd. if side = CUBLAS_SIDE_RIGHT, the number of rows in the original k-by-n matrix reduced by gebrd.</param>
            <param name="A">array of dimension lda * n On entry, the vectors which define the
            elementary reflectors, as returned by gebrd. On exit, the m-by-n matrix Q or P**T.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m);</param>
            <param name="tau">array of dimension min(m,k) if side is CUBLAS_SIDE_LEFT; of dimension min(n,k) if side is
            CUBLAS_SIDE_RIGHT; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q
            or P**T, as returned by gebrd in its array argument TAUQ or TAUP.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
            <param name="work">working space, array of size lwork.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZungbr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generates one of the unitary matrices Q or P**T determined by GEBRD
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">if side = CUBLAS_SIDE_LEFT, generate Q. if side = CUBLAS_SIDE_RIGHT, generate P**T.</param>
            <param name="m">number of rows of matrix Q or P**T.</param>
            <param name="n">if side = CUBLAS_SIDE_LEFT, m>= n>= min(m,k). if side = CUBLAS_SIDE_RIGHT, n>= m>= min(n,k).</param>
            <param name="k">if side = CUBLAS_SIDE_LEFT, the number of columns in the original mby-
            k matrix reduced by gebrd. if side = CUBLAS_SIDE_RIGHT, the number of rows in the original k-by-n matrix reduced by gebrd.</param>
            <param name="A">array of dimension lda * n On entry, the vectors which define the
            elementary reflectors, as returned by gebrd. On exit, the m-by-n matrix Q or P**T.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,m);</param>
            <param name="tau">array of dimension min(m,k) if side is CUBLAS_SIDE_LEFT; of dimension min(n,k) if side is
            CUBLAS_SIDE_RIGHT; tau(i) must contain the scalar factor of the elementary reflector H(i) or G(i), which determines Q
            or P**T, as returned by gebrd in its array argument TAUQ or TAUP.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
            <param name="work">working space, array of size lwork.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSorgtr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generate unitary Q comes from sytrd
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">uplo = CUBLAS_FILL_MODE_LOWER: Lower triangle of A contains elementary
            reflectors from sytrd. uplo = CUBLAS_FILL_MODE_UPPER: Upper triangle of A contains elementary
            reflectors from sytrd.</param>
            <param name="n">number of rows (columns) of matrix Q.</param>
            <param name="A">array of dimension lda * n On entry, matrix A from sytrd contains the elementary reflectors. On exit, matrix A
            contains the n-by-n orthogonal matrix Q.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,n).</param>
            <param name="tau">array of dimension (n-1) tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDorgtr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generate unitary Q comes from sytrd
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">uplo = CUBLAS_FILL_MODE_LOWER: Lower triangle of A contains elementary
            reflectors from sytrd. uplo = CUBLAS_FILL_MODE_UPPER: Upper triangle of A contains elementary
            reflectors from sytrd.</param>
            <param name="n">number of rows (columns) of matrix Q.</param>
            <param name="A">array of dimension lda * n On entry, matrix A from sytrd contains the elementary reflectors. On exit, matrix A
            contains the n-by-n orthogonal matrix Q.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,n).</param>
            <param name="tau">array of dimension (n-1) tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCungtr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generate unitary Q comes from sytrd
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">uplo = CUBLAS_FILL_MODE_LOWER: Lower triangle of A contains elementary
            reflectors from sytrd. uplo = CUBLAS_FILL_MODE_UPPER: Upper triangle of A contains elementary
            reflectors from sytrd.</param>
            <param name="n">number of rows (columns) of matrix Q.</param>
            <param name="A">array of dimension lda * n On entry, matrix A from sytrd contains the elementary reflectors. On exit, matrix A
            contains the n-by-n orthogonal matrix Q.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,n).</param>
            <param name="tau">array of dimension (n-1) tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZungtr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            generate unitary Q comes from sytrd
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">uplo = CUBLAS_FILL_MODE_LOWER: Lower triangle of A contains elementary
            reflectors from sytrd. uplo = CUBLAS_FILL_MODE_UPPER: Upper triangle of A contains elementary
            reflectors from sytrd.</param>
            <param name="n">number of rows (columns) of matrix Q.</param>
            <param name="A">array of dimension lda * n On entry, matrix A from sytrd contains the elementary reflectors. On exit, matrix A
            contains the n-by-n orthogonal matrix Q.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,n).</param>
            <param name="tau">array of dimension (n-1) tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSorgtr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generate unitary Q comes from sytrd
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">uplo = CUBLAS_FILL_MODE_LOWER: Lower triangle of A contains elementary
            reflectors from sytrd. uplo = CUBLAS_FILL_MODE_UPPER: Upper triangle of A contains elementary
            reflectors from sytrd.</param>
            <param name="n">number of rows (columns) of matrix Q.</param>
            <param name="A">array of dimension lda * n On entry, matrix A from sytrd contains the elementary reflectors. On exit, matrix A
            contains the n-by-n orthogonal matrix Q.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,n).</param>
            <param name="tau">array of dimension (n-1) tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="info">if info = 0, the orgtr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDorgtr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generate unitary Q comes from sytrd
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">uplo = CUBLAS_FILL_MODE_LOWER: Lower triangle of A contains elementary
            reflectors from sytrd. uplo = CUBLAS_FILL_MODE_UPPER: Upper triangle of A contains elementary
            reflectors from sytrd.</param>
            <param name="n">number of rows (columns) of matrix Q.</param>
            <param name="A">array of dimension lda * n On entry, matrix A from sytrd contains the elementary reflectors. On exit, matrix A
            contains the n-by-n orthogonal matrix Q.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,n).</param>
            <param name="tau">array of dimension (n-1) tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="info">if info = 0, the orgtr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCungtr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generate unitary Q comes from sytrd
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">uplo = CUBLAS_FILL_MODE_LOWER: Lower triangle of A contains elementary
            reflectors from sytrd. uplo = CUBLAS_FILL_MODE_UPPER: Upper triangle of A contains elementary
            reflectors from sytrd.</param>
            <param name="n">number of rows (columns) of matrix Q.</param>
            <param name="A">array of dimension lda * n On entry, matrix A from sytrd contains the elementary reflectors. On exit, matrix A
            contains the n-by-n orthogonal matrix Q.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,n).</param>
            <param name="tau">array of dimension (n-1) tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="info">if info = 0, the orgtr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZungtr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            generate unitary Q comes from sytrd
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="uplo">uplo = CUBLAS_FILL_MODE_LOWER: Lower triangle of A contains elementary
            reflectors from sytrd. uplo = CUBLAS_FILL_MODE_UPPER: Upper triangle of A contains elementary
            reflectors from sytrd.</param>
            <param name="n">number of rows (columns) of matrix Q.</param>
            <param name="A">array of dimension lda * n On entry, matrix A from sytrd contains the elementary reflectors. On exit, matrix A
            contains the n-by-n orthogonal matrix Q.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda >= max(1,n).</param>
            <param name="tau">array of dimension (n-1) tau(i) is the scalar of i-th elementary reflection vector.</param>
            <param name="lwork">size of working array work.</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="info">if info = 0, the orgtr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSormtr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function overwrites m×n matrix C by
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">side = CUBLAS_SIDE_LEFT, apply Q or Q**T from the Left; 
            side = CUBLAS_SIDE_RIGHT, apply Q or Q**T from the Right.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix C.</param>
            <param name="n">number of columns of matrix C.</param>
            <param name="A">array of dimension lda * m if side = CUBLAS_SIDE_LEFT; lda * n if
            side = CUBLAS_SIDE_RIGHT. The matrix A from sytrd contains the elementary reflectors.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. if side is
            CUBLAS_SIDE_LEFT, lda &gt;= max(1,m); if side is CUBLAS_SIDE_RIGHT, lda &gt;= max(1,n).</param>
            <param name="tau">array of dimension (m-1) if side is CUBLAS_SIDE_LEFT; of dimension
            (n-1) if side is CUBLAS_SIDE_RIGHT; The vector tau is from sytrd, so tau(i) 
            is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C or C*op(Q).</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDormtr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function overwrites m×n matrix C by
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">side = CUBLAS_SIDE_LEFT, apply Q or Q**T from the Left; 
            side = CUBLAS_SIDE_RIGHT, apply Q or Q**T from the Right.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix C.</param>
            <param name="n">number of columns of matrix C.</param>
            <param name="A">array of dimension lda * m if side = CUBLAS_SIDE_LEFT; lda * n if
            side = CUBLAS_SIDE_RIGHT. The matrix A from sytrd contains the elementary reflectors.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. if side is
            CUBLAS_SIDE_LEFT, lda &gt;= max(1,m); if side is CUBLAS_SIDE_RIGHT, lda &gt;= max(1,n).</param>
            <param name="tau">array of dimension (m-1) if side is CUBLAS_SIDE_LEFT; of dimension
            (n-1) if side is CUBLAS_SIDE_RIGHT; The vector tau is from sytrd, so tau(i) 
            is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C or C*op(Q).</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCunmtr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function overwrites m×n matrix C by
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">side = CUBLAS_SIDE_LEFT, apply Q or Q**T from the Left; 
            side = CUBLAS_SIDE_RIGHT, apply Q or Q**T from the Right.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix C.</param>
            <param name="n">number of columns of matrix C.</param>
            <param name="A">array of dimension lda * m if side = CUBLAS_SIDE_LEFT; lda * n if
            side = CUBLAS_SIDE_RIGHT. The matrix A from sytrd contains the elementary reflectors.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. if side is
            CUBLAS_SIDE_LEFT, lda &gt;= max(1,m); if side is CUBLAS_SIDE_RIGHT, lda &gt;= max(1,n).</param>
            <param name="tau">array of dimension (m-1) if side is CUBLAS_SIDE_LEFT; of dimension
            (n-1) if side is CUBLAS_SIDE_RIGHT; The vector tau is from sytrd, so tau(i) 
            is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C or C*op(Q).</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZunmtr_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32@)">
            <summary>
            This function overwrites m×n matrix C by
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">side = CUBLAS_SIDE_LEFT, apply Q or Q**T from the Left; 
            side = CUBLAS_SIDE_RIGHT, apply Q or Q**T from the Right.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix C.</param>
            <param name="n">number of columns of matrix C.</param>
            <param name="A">array of dimension lda * m if side = CUBLAS_SIDE_LEFT; lda * n if
            side = CUBLAS_SIDE_RIGHT. The matrix A from sytrd contains the elementary reflectors.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. if side is
            CUBLAS_SIDE_LEFT, lda &gt;= max(1,m); if side is CUBLAS_SIDE_RIGHT, lda &gt;= max(1,n).</param>
            <param name="tau">array of dimension (m-1) if side is CUBLAS_SIDE_LEFT; of dimension
            (n-1) if side is CUBLAS_SIDE_RIGHT; The vector tau is from sytrd, so tau(i) 
            is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C or C*op(Q).</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="lwork">size of working array work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSormtr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function overwrites m×n matrix C by
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">side = CUBLAS_SIDE_LEFT, apply Q or Q**T from the Left; 
            side = CUBLAS_SIDE_RIGHT, apply Q or Q**T from the Right.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix C.</param>
            <param name="n">number of columns of matrix C.</param>
            <param name="A">array of dimension lda * m if side = CUBLAS_SIDE_LEFT; lda * n if
            side = CUBLAS_SIDE_RIGHT. The matrix A from sytrd contains the elementary reflectors.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. if side is
            CUBLAS_SIDE_LEFT, lda &gt;= max(1,m); if side is CUBLAS_SIDE_RIGHT, lda &gt;= max(1,n).</param>
            <param name="tau">array of dimension (m-1) if side is CUBLAS_SIDE_LEFT; of dimension
            (n-1) if side is CUBLAS_SIDE_RIGHT; The vector tau is from sytrd, so tau(i) 
            is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C or C*op(Q).</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDormtr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function overwrites m×n matrix C by
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">side = CUBLAS_SIDE_LEFT, apply Q or Q**T from the Left; 
            side = CUBLAS_SIDE_RIGHT, apply Q or Q**T from the Right.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix C.</param>
            <param name="n">number of columns of matrix C.</param>
            <param name="A">array of dimension lda * m if side = CUBLAS_SIDE_LEFT; lda * n if
            side = CUBLAS_SIDE_RIGHT. The matrix A from sytrd contains the elementary reflectors.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. if side is
            CUBLAS_SIDE_LEFT, lda &gt;= max(1,m); if side is CUBLAS_SIDE_RIGHT, lda &gt;= max(1,n).</param>
            <param name="tau">array of dimension (m-1) if side is CUBLAS_SIDE_LEFT; of dimension
            (n-1) if side is CUBLAS_SIDE_RIGHT; The vector tau is from sytrd, so tau(i) 
            is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C or C*op(Q).</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCunmtr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function overwrites m×n matrix C by
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">side = CUBLAS_SIDE_LEFT, apply Q or Q**T from the Left; 
            side = CUBLAS_SIDE_RIGHT, apply Q or Q**T from the Right.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix C.</param>
            <param name="n">number of columns of matrix C.</param>
            <param name="A">array of dimension lda * m if side = CUBLAS_SIDE_LEFT; lda * n if
            side = CUBLAS_SIDE_RIGHT. The matrix A from sytrd contains the elementary reflectors.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. if side is
            CUBLAS_SIDE_LEFT, lda &gt;= max(1,m); if side is CUBLAS_SIDE_RIGHT, lda &gt;= max(1,n).</param>
            <param name="tau">array of dimension (m-1) if side is CUBLAS_SIDE_LEFT; of dimension
            (n-1) if side is CUBLAS_SIDE_RIGHT; The vector tau is from sytrd, so tau(i) 
            is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C or C*op(Q).</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZunmtr(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaBlas.SideMode,ManagedCuda.CudaBlas.FillMode,ManagedCuda.CudaBlas.Operation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function overwrites m×n matrix C by
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="side">side = CUBLAS_SIDE_LEFT, apply Q or Q**T from the Left; 
            side = CUBLAS_SIDE_RIGHT, apply Q or Q**T from the Right.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="trans">operation op(Q) that is non- or (conj.) transpose.</param>
            <param name="m">number of rows of matrix C.</param>
            <param name="n">number of columns of matrix C.</param>
            <param name="A">array of dimension lda * m if side = CUBLAS_SIDE_LEFT; lda * n if
            side = CUBLAS_SIDE_RIGHT. The matrix A from sytrd contains the elementary reflectors.</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. if side is
            CUBLAS_SIDE_LEFT, lda &gt;= max(1,m); if side is CUBLAS_SIDE_RIGHT, lda &gt;= max(1,n).</param>
            <param name="tau">array of dimension (m-1) if side is CUBLAS_SIDE_LEFT; of dimension
            (n-1) if side is CUBLAS_SIDE_RIGHT; The vector tau is from sytrd, so tau(i) 
            is the scalar of i-th elementary reflection vector.</param>
            <param name="C">array of size ldc * n. On exit, C is overwritten by op(Q)*C or C*op(Q).</param>
            <param name="ldc">leading dimension of two-dimensional array of matrix C. ldc &gt;= max(1,m).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of working array work.</param>
            <param name="info">if info = 0, the ormqr is successful. if info = -i, the i-th parameter is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSsyevd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix A.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="lwork">size of work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDsyevd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix A.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="lwork">size of work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCheevd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix A.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="lwork">size of work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZheevd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix A.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="lwork">size of work.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSsyevd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix A.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of work, returned by sygvd_bufferSize.</param>
            <param name="info">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i (&gt;0), devInfo indicates either potrf or syevd is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDsyevd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix A.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of work, returned by sygvd_bufferSize.</param>
            <param name="info">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i (&gt;0), devInfo indicates either potrf or syevd is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnCheevd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix A.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of work, returned by sygvd_bufferSize.</param>
            <param name="info">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i (&gt;0), devInfo indicates either potrf or syevd is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZheevd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix A.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of work, returned by sygvd_bufferSize.</param>
            <param name="info">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i (&gt;0), devInfo indicates either potrf or syevd is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSsygvd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigType,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            The helper functions below can calculate the sizes needed for pre-allocated buffer.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="itype">Specifies the problem type to be solved.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="B">array of dimension ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B. ldb is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="lwork">size of work</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDsygvd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigType,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            The helper functions below can calculate the sizes needed for pre-allocated buffer.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="itype">Specifies the problem type to be solved.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="B">array of dimension ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B. ldb is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="lwork">size of work</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnChegvd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigType,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            The helper functions below can calculate the sizes needed for pre-allocated buffer.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="itype">Specifies the problem type to be solved.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="B">array of dimension ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B. ldb is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="lwork">size of work</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZhegvd_bufferSize(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigType,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            The helper functions below can calculate the sizes needed for pre-allocated buffer.
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="itype">Specifies the problem type to be solved.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="B">array of dimension ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B. ldb is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="lwork">size of work</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnSsygvd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigType,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix-pair (A,B).
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="itype">Specifies the problem type to be solved.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="B">array of dimension ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B. ldb is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of work, returned by sygvd_bufferSize.</param>
            <param name="info">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i (&gt;0), devInfo indicates either potrf or syevd is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnDsygvd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigType,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix-pair (A,B).
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="itype">Specifies the problem type to be solved.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="B">array of dimension ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B. ldb is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of work, returned by sygvd_bufferSize.</param>
            <param name="info">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i (&gt;0), devInfo indicates either potrf or syevd is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnChegvd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigType,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix-pair (A,B).
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="itype">Specifies the problem type to be solved.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="B">array of dimension ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B. ldb is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of work, returned by sygvd_bufferSize.</param>
            <param name="info">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i (&gt;0), devInfo indicates either potrf or syevd is wrong.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Dense.cusolverDnZhegvd(ManagedCuda.CudaSolve.cusolverDnHandle,ManagedCuda.CudaSolve.cusolverEigType,ManagedCuda.CudaSolve.cusolverEigMode,ManagedCuda.CudaBlas.FillMode,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function computes eigenvalues and eigenvectors of a symmetric (Hermitian) n×n matrix-pair (A,B).
            </summary>
            <param name="handle">handle to the cuSolverDN library context.</param>
            <param name="itype">Specifies the problem type to be solved.</param>
            <param name="jobz">specifies options to either compute eigenvalue only or compute eigen-pair.</param>
            <param name="uplo">specifies which part of A and B are stored.</param>
            <param name="n">number of rows (or columns) of matrix A and B.</param>
            <param name="A">array of dimension lda * n with lda is not less than max(1,n).</param>
            <param name="lda">leading dimension of two-dimensional array used to store matrix A. lda is not less than max(1,n).</param>
            <param name="B">array of dimension ldb * n.</param>
            <param name="ldb">leading dimension of two-dimensional array used to store matrix B. ldb is not less than max(1,n).</param>
            <param name="W">a real array of dimension n. The eigenvalue values of A, sorted so that W(i) &gt;= W(i+1).</param>
            <param name="work">working space, array of size lwork.</param>
            <param name="lwork">size of work, returned by sygvd_bufferSize.</param>
            <param name="info">if devInfo = 0, the operation is successful. if devInfo = -i, the i-th
            parameter is wrong. if devInfo = i (&gt;0), devInfo indicates either potrf or syevd is wrong.</param>
        </member>
        <member name="T:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse">
            <summary>
            The cuSolverSP library was mainly designed to a solve sparse linear system AxB and the least-squares problem
            x = argmin||A*z-b||
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCreate(ManagedCuda.CudaSolve.cusolverSpHandle@)">
            <summary>
            This function initializes the cuSolverSP library and creates a handle on the cuSolver
            context. It must be called before any other cuSolverSP API function is invoked. It
            allocates hardware resources necessary for accessing the GPU.
            </summary>
            <param name="handle">the pointer to the handle to the cuSolverSP context.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDestroy(ManagedCuda.CudaSolve.cusolverSpHandle)">
            <summary>
            This function releases CPU-side resources used by the cuSolverSP library.
            </summary>
            <param name="handle">the handle to the cuSolverSP context.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpSetStream(ManagedCuda.CudaSolve.cusolverSpHandle,ManagedCuda.BasicTypes.CUstream)">
            <summary>
            This function sets the stream to be used by the cuSolverSP library to execute its routines.
            </summary>
            <param name="handle">the handle to the cuSolverSP context.</param>
            <param name="streamId">the stream to be used by the library.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpGetStream(ManagedCuda.CudaSolve.cusolverSpHandle,ManagedCuda.BasicTypes.CUstream@)">
            <summary>
            This function gets the stream to be used by the cuSolverSP library to execute its routines.
            </summary>
            <param name="handle">the handle to the cuSolverSP context.</param>
            <param name="streamId">the stream to be used by the library.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpXcsrissymHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32[],System.Int32[],System.Int32[],System.Int32@)">
            <summary>
            This function checks if A has symmetric pattern or not. The output parameter issym
            reports 1 if A is symmetric; otherwise, it reports 0.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m elements that contains the start of every row.</param>
            <param name="csrEndPtrA">integer array of m elements that contains the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of matrix A.</param>
            <param name="issym">1 if A is symmetric; 0 otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsrlsvluHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single,System.Int32,System.Single[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size n.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no ordering if reorder=0. Otherwise, symrcm is used to reduce zero fill-in.</param>
            <param name="x">solution vector of size n, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsrlsvluHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double,System.Int32,System.Double[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size n.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no ordering if reorder=0. Otherwise, symrcm is used to reduce zero fill-in.</param>
            <param name="x">solution vector of size n, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsrlsvluHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex[],System.Single,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size n.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no ordering if reorder=0. Otherwise, symrcm is used to reduce zero fill-in.</param>
            <param name="x">solution vector of size n, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsrlsvluHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex[],System.Double,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size n.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no ordering if reorder=0. Otherwise, symrcm is used to reduce zero fill-in.</param>
            <param name="x">solution vector of size n, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsrlsvqr(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that R(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsrlsvqr(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that R(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsrlsvqr(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that R(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsrlsvqr(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that R(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsrlsvqrHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single,System.Int32,System.Single[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that R(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsrlsvqrHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double,System.Int32,System.Double[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that R(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsrlsvqrHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex[],System.Single,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that R(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsrlsvqrHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex[],System.Double,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is invertible. Otherwise, first index j such that R(j,j)≈0</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsrlsvcholHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single,System.Int32,System.Single[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is symmetric postive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsrlsvcholHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double,System.Int32,System.Double[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is symmetric postive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsrlsvcholHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex[],System.Single,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is symmetric postive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsrlsvcholHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex[],System.Double,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is symmetric postive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsrlsvchol(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is symmetric postive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsrlsvchol(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is symmetric postive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsrlsvchol(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is symmetric postive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsrlsvchol(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <param name="singularity">-1 if A is symmetric postive definite.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsrlsqvqrHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single,System.Int32@,System.Single[],System.Int32[],System.Single@)">
            <summary>
            This function solves the following least-square problem x = argmin||A*z-b||
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide rank of A.</param>
            <param name="rankA">numerical rank of A.</param>
            <param name="x">solution vector of size n, x=pinv(A)*b.</param>
            <param name="p">a vector of size n, which represents the permuation matrix P satisfying A*P^T=Q*R.</param>
            <param name="min_norm">||A*x-b||, x=pinv(A)*b.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsrlsqvqrHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double,System.Int32@,System.Double[],System.Int32[],System.Double@)">
            <summary>
            This function solves the following least-square problem x = argmin||A*z-b||
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide rank of A.</param>
            <param name="rankA">numerical rank of A.</param>
            <param name="x">solution vector of size n, x=pinv(A)*b.</param>
            <param name="p">a vector of size n, which represents the permuation matrix P satisfying A*P^T=Q*R.</param>
            <param name="min_norm">||A*x-b||, x=pinv(A)*b.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsrlsqvqrHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex[],System.Single,System.Int32@,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Single@)">
            <summary>
            This function solves the following least-square problem x = argmin||A*z-b||
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide rank of A.</param>
            <param name="rankA">numerical rank of A.</param>
            <param name="x">solution vector of size n, x=pinv(A)*b.</param>
            <param name="p">a vector of size n, which represents the permuation matrix P satisfying A*P^T=Q*R.</param>
            <param name="min_norm">||A*x-b||, x=pinv(A)*b.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsrlsqvqrHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex[],System.Double,System.Int32@,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Double@)">
            <summary>
            This function solves the following least-square problem x = argmin||A*z-b||
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide rank of A.</param>
            <param name="rankA">numerical rank of A.</param>
            <param name="x">solution vector of size n, x=pinv(A)*b.</param>
            <param name="p">a vector of size n, which represents the permuation matrix P satisfying A*P^T=Q*R.</param>
            <param name="min_norm">||A*x-b||, x=pinv(A)*b.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsreigvsiHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Single[],System.Int32[],System.Int32[],System.Single,System.Single[],System.Int32,System.Single,System.Single@,System.Single[])">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsreigvsiHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Double[],System.Int32[],System.Int32[],System.Double,System.Double[],System.Int32,System.Double,System.Double@,System.Double[])">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsreigvsiHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32,System.Single,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.VectorTypes.cuFloatComplex[])">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsreigvsiHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32,System.Double,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.VectorTypes.cuDoubleComplex[])">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsreigvsi(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsreigvsi(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsreigvsi(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsreigvsi(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsreigsHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Single[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.VectorTypes.cuFloatComplex,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsreigsHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Double[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.VectorTypes.cuDoubleComplex,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsreigsHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.VectorTypes.cuFloatComplex,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsreigsHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.VectorTypes.cuDoubleComplex,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpXcsrsymrcmHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            This function implements Symmetric Reverse Cuthill-McKee permutation. It returns a
            permutation vector p such that A(p,p) would concentrate nonzeros to diagonal. This is
            equivalent to symrcm in MATLAB, however the result may not be the same because of
            different heuristics in the pseudoperipheral finder.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">permutation vector of size n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpXcsrsymmdqHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Symmetric minimum degree algorithm based on quotient graph.<para/>
            This function implements Symmetric Minimum Degree Algorithm based on Quotient
            Graph. It returns a permutation vector p such that A(p,p) would have less zero fill-in
            during Cholesky factorization.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">permutation vector of size n.</param>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpXcsrsymamdHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Symmetric Approximate minimum degree algorithm based on quotient graph.<para/>
            This function implements Symmetric Approximate Minimum Degree Algorithm based
            on Quotient Graph. It returns a permutation vector p such that A(p,p) would have less
            zero fill-in during Cholesky factorization.
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">permutation vector of size n.</param>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpXcsrperm_bufferSizeHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32[],System.Int32[],System.Int32[],System.Int32[],ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            Given a left permutation vector p which corresponds to permutation matrix P and a
            right permutation vector q which corresponds to permutation matrix Q, this function
            computes permutation of matrix A by B = P*A*Q^T
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">left permutation vector of size m.</param>
            <param name="q">right permutation vector of size n.</param>
            <param name="bufferSizeInBytes">number of bytes of the buffer.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpXcsrpermHost(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Byte[])">
            <summary>
            Given a left permutation vector p which corresponds to permutation matrix P and a
            right permutation vector q which corresponds to permutation matrix Q, this function
            computes permutation of matrix A by B = P*A*Q^T
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">left permutation vector of size m.</param>
            <param name="q">right permutation vector of size n.</param>
            <param name="map">integer array of nnzA indices. If the user wants to
            get relationship between A and B, map must be set 0:1:(nnzA-1).</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned by csrperm_bufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCreateCsrqrInfo(ManagedCuda.CudaSolve.csrqrInfo@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="info">opaque structure for QR factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDestroyCsrqrInfo(ManagedCuda.CudaSolve.csrqrInfo)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="info">opaque structure for QR factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpXcsrqrAnalysisBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSolve.csrqrInfo)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnzA">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="info">opaque structure for QR factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsrqrBufferInfoBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSolve.csrqrInfo,ManagedCuda.BasicTypes.SizeT@,ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="internalDataInBytes">number of bytes of the internal data.</param>
            <param name="workspaceInBytes">number of bytes of the buffer in numerical factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsrqrBufferInfoBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSolve.csrqrInfo,ManagedCuda.BasicTypes.SizeT@,ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="internalDataInBytes">number of bytes of the internal data.</param>
            <param name="workspaceInBytes">number of bytes of the buffer in numerical factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsrqrBufferInfoBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSolve.csrqrInfo,ManagedCuda.BasicTypes.SizeT@,ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="internalDataInBytes">number of bytes of the internal data.</param>
            <param name="workspaceInBytes">number of bytes of the buffer in numerical factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsrqrBufferInfoBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSolve.csrqrInfo,ManagedCuda.BasicTypes.SizeT@,ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="internalDataInBytes">number of bytes of the internal data.</param>
            <param name="workspaceInBytes">number of bytes of the buffer in numerical factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpScsrqrsvBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSolve.csrqrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="b">array of m*batchSize of right-hand-side vectors b0, b1, .... All vectors are aggregated one after another.</param>
            <param name="x">array of m*batchSize of solution vectors x0, x1, .... All vectors are aggregated one after another.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned
            by cusolverSpXcsrqrBufferInfoBatched().</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpDcsrqrsvBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSolve.csrqrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="b">array of m*batchSize of right-hand-side vectors b0, b1, .... All vectors are aggregated one after another.</param>
            <param name="x">array of m*batchSize of solution vectors x0, x1, .... All vectors are aggregated one after another.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned
            by cusolverSpXcsrqrBufferInfoBatched().</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpCcsrqrsvBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSolve.csrqrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="b">array of m*batchSize of right-hand-side vectors b0, b1, .... All vectors are aggregated one after another.</param>
            <param name="x">array of m*batchSize of solution vectors x0, x1, .... All vectors are aggregated one after another.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned
            by cusolverSpXcsrqrBufferInfoBatched().</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Sparse.cusolverSpZcsrqrsvBatched(ManagedCuda.CudaSolve.cusolverSpHandle,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSolve.csrqrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="handle">handle to the cuSolverSP library context.</param>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="b">array of m*batchSize of right-hand-side vectors b0, b1, .... All vectors are aggregated one after another.</param>
            <param name="x">array of m*batchSize of solution vectors x0, x1, .... All vectors are aggregated one after another.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned
            by cusolverSpXcsrqrBufferInfoBatched().</param>
        </member>
        <member name="T:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization">
            <summary>
            The cuSolverRF library was designed to accelerate solution of sets of linear systems by
            fast re-factorization when given new coefficients in the same sparsity pattern
            A_i x_i = f_i
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfCreate(ManagedCuda.CudaSolve.cusolverRfHandle@)">
            <summary>
            This routine initializes the cuSolverRF library. It allocates required resources and must be called prior to any other cuSolverRF library routine.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfDestroy(ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine shuts down the cuSolverRF library. It releases acquired resources and must be called after all the cuSolverRF library routines.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfGetMatrixFormat(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.CudaSolve.MatrixFormat@,ManagedCuda.CudaSolve.UnitDiagonal@)">
            <summary>
            This routine gets the matrix format used in the cusolverRfSetup(),
            cusolverRfSetupHost(), cusolverRfResetValues(), cusolverRfExtractBundledFactorsHost() and cusolverRfExtractSplitFactorsHost() routines.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="format">the enumerated matrix format type.</param>
            <param name="diag">the enumerated unit diagonal type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfSetMatrixFormat(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.CudaSolve.MatrixFormat,ManagedCuda.CudaSolve.UnitDiagonal)">
            <summary>
            This routine sets the matrix format used in the cusolverRfSetup(),
            cusolverRfSetupHost(), cusolverRfResetValues(), cusolverRfExtractBundledFactorsHost() and cusolverRfExtractSplitFactorsHost() routines.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="format">the enumerated matrix format type.</param>
            <param name="diag">the enumerated unit diagonal type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfSetNumericProperties(ManagedCuda.CudaSolve.cusolverRfHandle,System.Double,System.Double)">
            <summary>
            This routine sets the numeric values used for checking for "zero" pivot and for boosting
            it in the cusolverRfRefactor() and cusolverRfSolve() routines. It may be called 
            multiple times prior to cusolverRfRefactor() and cusolverRfSolve() routines.
            The numeric boosting will be used only if boost &gt; 0.0.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="zero">the value below which zero pivot is flagged.</param>
            <param name="boost">the value which is substituted for zero pivot (if the later is flagged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfGetNumericProperties(ManagedCuda.CudaSolve.cusolverRfHandle,System.Double@,System.Double@)">
            <summary>
            This routine gets the numeric values used for checking for "zero" pivot and for boosting
            it in the cusolverRfRefactor() and cusolverRfSolve() routines. It may be called 
            multiple times prior to cusolverRfRefactor() and cusolverRfSolve() routines.
            The numeric boosting will be used only if boost &gt; 0.0.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="zero">the value below which zero pivot is flagged.</param>
            <param name="boost">the value which is substituted for zero pivot (if the later is flagged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfGetNumericBoostReport(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.CudaSolve.NumericBoostReport@)">
            <summary>
            This routine gets the report whether numeric boosting was used in the
            cusolverRfRefactor() and cusolverRfSolve() routines.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="report">the enumerated boosting report type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfSetAlgs(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.CudaSolve.Factorization,ManagedCuda.CudaSolve.TriangularSolve)">
            <summary>
            This routine sets the algorithm used for the refactorization in cusolverRfRefactor()
            and the triangular solve in cusolverRfSolve(). It may be called once prior to
            cusolverRfAnalyze() routine.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="factAlg">the enumerated algorithm type.</param>
            <param name="solveAlg">the enumerated algorithm type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfGetAlgs(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.CudaSolve.Factorization@,ManagedCuda.CudaSolve.TriangularSolve@)">
            <summary>
            This routine gets the algorithm used for the refactorization in cusolverRfRefactor()
            and the triangular solve in cusolverRfSolve(). It may be called once prior to
            cusolverRfAnalyze() routine.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="factAlg">the enumerated algorithm type.</param>
            <param name="solveAlg">the enumerated algorithm type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfGetResetValuesFastMode(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.CudaSolve.ResetValuesFastMode@)">
            <summary>
            This routine gets the mode used in the cusolverRfResetValues routine.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="fastMode">the enumerated mode type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfSetResetValuesFastMode(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.CudaSolve.ResetValuesFastMode)">
            <summary>
            This routine sets the mode used in the cusolverRfResetValues routine.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="fastMode">the enumerated mode type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfSetupHost(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[],ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>This routine assembles the internal data structures of the cuSolverRF library. It is often
            the first routine to be called after the call to the cusolverRfCreate() routine.
            </summary>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="h_csrRowPtrA">the array of offsets corresponding to 
            the start of each row in the arrays h_csrColIndA and h_csrValA. This
            array has also an extra entry at the end that stores the number of non-zero
            elements in the matrix. The array size is n+1.</param>
            <param name="h_csrColIndA">the array of column indices corresponding
            to the non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="h_csrValA">the array of values corresponding to the
            non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="nnzL">the number of non-zero elements of matrix L.</param>
            <param name="h_csrRowPtrL">the array of offsets corresponding to
            the start of each row in the arrays h_csrColIndL and h_csrValL. This
            array has also an extra entry at the end that stores the number of non-zero
            elements in the matrix L. The array size is n+1.</param>
            <param name="h_csrColIndL">the array of column indices corresponding
            to the non-zero elements in the matrix L. It is assumed that this array is sorted by
            row and by column within each row. The array size is nnzL.</param>
            <param name="h_csrValL">the array of values corresponding to the
            non-zero elements in the matrix L. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzL.</param>
            <param name="nnzU">the number of non-zero elements of matrix U.</param>
            <param name="h_csrRowPtrU">the array of offsets corresponding to
            the start of each row in the arrays h_csrColIndU and h_csrValU. This
            array has also an extra entry at the end that stores the number of non-zero elements in the matrix U. The array size is n+1.</param>
            <param name="h_csrColIndU">the array of column indices corresponding 
            to the non-zero elements in the matrix U. It is assumed that this array is sorted by row and by column within each row. The array size is nnzU.</param>
            <param name="h_csrValU">the array of values corresponding to the non-zero elements in the matrix U. It is
            assumed that this array is sorted by row and by column within each row. The array size is nnzU.</param>
            <param name="h_P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="h_Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfSetupDevice(System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>This routine assembles the internal data structures of the cuSolverRF library. It is often
            the first routine to be called after the call to the cusolverRfCreate() routine.
            </summary>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">the array of offsets corresponding to 
            the start of each row in the arrays h_csrColIndA and h_csrValA. This
            array has also an extra entry at the end that stores the number of non-zero
            elements in the matrix. The array size is n+1.</param>
            <param name="csrColIndA">the array of column indices corresponding
            to the non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="csrValA">the array of values corresponding to the
            non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="nnzL">the number of non-zero elements of matrix L.</param>
            <param name="csrRowPtrL">the array of offsets corresponding to
            the start of each row in the arrays h_csrColIndL and h_csrValL. This
            array has also an extra entry at the end that stores the number of non-zero
            elements in the matrix L. The array size is n+1.</param>
            <param name="csrColIndL">the array of column indices corresponding
            to the non-zero elements in the matrix L. It is assumed that this array is sorted by
            row and by column within each row. The array size is nnzL.</param>
            <param name="csrValL">the array of values corresponding to the
            non-zero elements in the matrix L. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzL.</param>
            <param name="nnzU">the number of non-zero elements of matrix U.</param>
            <param name="csrRowPtrU">the array of offsets corresponding to
            the start of each row in the arrays h_csrColIndU and h_csrValU. This
            array has also an extra entry at the end that stores the number of non-zero elements in the matrix U. The array size is n+1.</param>
            <param name="csrColIndU">the array of column indices corresponding 
            to the non-zero elements in the matrix U. It is assumed that this array is sorted by row and by column within each row. The array size is nnzU.</param>
            <param name="csrValU">the array of values corresponding to the non-zero elements in the matrix U. It is
            assumed that this array is sorted by row and by column within each row. The array size is nnzU.</param>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfResetValues(System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine updates internal data structures with the values of the new coefficient
            matrix. It is assumed that the arrays csrRowPtrA, csrColIndA, P and Q have not
            changed since the last call to the cusolverRfSetup[Host] routine. This assumption
            reflects the fact that the sparsity pattern of coefficient matrices as well as reordering to
            minimize fill-in and pivoting remain the same in the set of linear systems
            </summary>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">the array of offsets corresponding to the start of each row in the arrays
            csrColIndA and csrValA. This array has also an extra entry at the end that stores the number of non-zero elements in the
            matrix. The array size is n+1.</param>
            <param name="csrColIndA">the array of column indices corresponding to the non-zero elements in the matrix. It
            is assumed that this array is sorted by row and by column within each row. The array size is nnzA.</param>
            <param name="csrValA">the array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfAnalyze(ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine performs the appropriate analysis of parallelism available in the LU refactorization depending upon the algorithm chosen by the user.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfRefactor(ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine performs the LU re-factorization
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfAccessBundledFactorsDevice(ManagedCuda.CudaSolve.cusolverRfHandle,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr@,ManagedCuda.BasicTypes.CUdeviceptr@,ManagedCuda.BasicTypes.CUdeviceptr@)">
            <summary>
            This routine allows direct access to the lower L and upper U triangular factors stored in
            the cuSolverRF library handle. The factors are compressed into a single matrix M=(LI)+
            U, where the unitary diagonal of L is not stored. It is assumed that a prior call to the
            cusolverRfRefactor() was done in order to generate these triangular factors.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="nnzM">the number of non-zero elements of matrix M.</param>
            <param name="Mp">the array of offsets corresponding to the start of each row in the arrays Mi and Mx.
            This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.</param>
            <param name="Mi">the array of column indices corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.</param>
            <param name="Mx">the array of values corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfExtractBundledFactorsHost(ManagedCuda.CudaSolve.cusolverRfHandle,System.Int32@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
            <summary>
            This routine allows direct access to the lower L and upper U triangular factors stored in
            the cuSolverRF library handle. The factors are compressed into a single matrix M=(LI)+
            U, where the unitary diagonal of L is not stored. It is assumed that a prior call to the
            cusolverRfRefactor() was done in order to generate these triangular factors.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="h_nnzM">the number of non-zero elements of matrix M.</param>
            <param name="h_Mp">the array of offsets corresponding to the start of each row in the arrays Mi and Mx.
            This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.</param>
            <param name="h_Mi">the array of column indices corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.</param>
            <param name="h_Mx">the array of values corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfExtractSplitFactorsHost(ManagedCuda.CudaSolve.cusolverRfHandle,System.Int32@,System.IntPtr@,System.IntPtr@,System.IntPtr@,System.Int32@,System.IntPtr@,System.IntPtr@,System.IntPtr@)">
            <summary>
            This routine extracts lower (L) and upper (U) triangular factors from the
            cuSolverRF library handle into the host memory. It is assumed that a prior call to the
            cusolverRfRefactor() was done in order to generate these triangular factors.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="h_nnzL">the number of non-zero elements of matrix L.</param>
            <param name="h_csrRowPtrL">the array of offsets corresponding to the start of each row in the arrays h_Li and
            h_Lx. This array has also an extra entry at the end that stores the number of nonzero elements in the matrix L. The array size is n+1.</param>
            <param name="h_csrColIndL">the array of column indices corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by
            row and by column within each row. The array size is h_nnzL.</param>
            <param name="h_csrValL">the array of values corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by row
            and by column within each row. The array size is h_nnzL.</param>
            <param name="h_nnzU">the number of non-zero elements of matrix U.</param>
            <param name="h_csrRowPtrU">the array of offsets corresponding to the start of each row in the arrays h_Ui and h_Ux. This array has also an extra entry
            at the end that stores the number of nonzero elements in the matrix U. The array size is n+1.</param>
            <param name="h_csrColIndU">the array of column indices corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by
            row and by column within each row. The array size is h_nnzU.</param>
            <param name="h_csrValU">the array of values corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by row
            and by column within each row. The array size is h_nnzU.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfSolve(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32)">
            <summary>
            This routine performs the forward and backward solve with the lower and upper
            triangular factors resulting from the LU re-factorization
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="nrhs">the number right-hand-sides to be solved.</param>
            <param name="Temp">the dense matrix that contains temporary workspace (of size ldt*nrhs).</param>
            <param name="ldt">the leading dimension of dense matrix Temp (ldt &gt;= n).</param>
            <param name="XF">the dense matrix that contains the righthand-sides F and solutions X (of size ldxf*nrhs).</param>
            <param name="ldxf">the leading dimension of dense matrix XF (ldxf &gt;= n).</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfBatchSetupHost(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.IntPtr[],System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[],ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine assembles the internal data structures of the cuSolverRF library for batched
            operation. It is called after the call to the cusolverRfCreate() routine, and before any
            other batched routines.
            </summary>
            <param name="batchSize">the number of matrices in the batched mode.</param>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="h_csrRowPtrA">the array of offsets corresponding to 
            the start of each row in the arrays h_csrColIndA and h_csrValA. This array has also an extra entry at the
            end that stores the number of non-zero elements in the matrix. The array size is n+1.</param>
            <param name="h_csrColIndA">the array of column indices corresponding 
            to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is nnzA.</param>
            <param name="h_csrValA_array">array of pointers of size batchSize, each pointer points to the array of values corresponding to the non-zero elements in the matrix.</param>
            <param name="nnzL">the number of non-zero elements of matrix L.</param>
            <param name="h_csrRowPtrL">the array of offsets corresponding to the start of each row in the arrays h_csrColIndL and h_csrValL. This
            array has also an extra entry at the end that stores the number of non-zero elements in the matrix L. The array size is n+1.</param>
            <param name="h_csrColIndL">the array of column indices corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by
            row and by column within each row. The array size is nnzL.</param>
            <param name="h_csrValL">the array of values corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzL.</param>
            <param name="nnzU">the number of non-zero elements of matrix U.</param>
            <param name="h_csrRowPtrU">the array of offsets corresponding to the start of each row in the arrays h_csrColIndU and h_csrValU. This
            array has also an extra entry at the end that stores the number of non-zero elements in the matrix U. The array size is n+1.</param>
            <param name="h_csrColIndU">the array of column indices corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by
            row and by column within each row. The array size is nnzU.</param> 
            <param name="h_csrValU">the array of values corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzU.</param>
            <param name="h_P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="h_Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfBatchResetValues(System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr[],ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine updates internal data structures with the values of the new coefficient
            matrix. It is assumed that the arrays csrRowPtrA, csrColIndA, P and Q have not 
            changed since the last call to the cusolverRfbatch_setup_host routine.
            </summary>
            <param name="batchSize">the number of matrices in batched mode.</param>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">the array of offsets corresponding to the start of each row in the arrays csrColIndA and csrValA. 
            This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is n+1.</param>
            <param name="csrColIndA">the array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="csrValA_array">array of pointers of size batchSize, each pointer points to the array of values corresponding to the non-zero elements in the matrix.</param>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfBatchAnalyze(ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine performs the appropriate analysis of parallelism available in the batched LU re-factorization.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfBatchRefactor(ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine performs the LU re-factorization
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfBatchSolve(ManagedCuda.CudaSolve.cusolverRfHandle,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double[],System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            To solve A_j * x_j = b_j, first we reform the equation by M_j * Q * x_j = P * b_j. Then do refactorization by
            cusolverRfBatch_Refactor(). Further cusolverRfBatch_Solve() takes over the remaining steps.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="nrhs">the number right-hand-sides to be solved.</param>
            <param name="Temp">the dense matrix that contains temporary workspace (of size ldt*nrhs).</param>
            <param name="ldt">the leading dimension of dense matrix Temp (ldt &gt;= n).</param>
            <param name="XF_array">array of pointers of size batchSize, each pointer points to the dense matrix that contains the right-hand-sides F and solutions X (of size ldxf*nrhs).</param>
            <param name="ldxf">the leading dimension of dense matrix XF (ldxf &gt;= n).</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveNativeMethods.Refactorization.cusolverRfBatchZeroPivot(ManagedCuda.CudaSolve.cusolverRfHandle,System.Int32[])">
            <summary>
            The user can query which matrix failed LU refactorization by checking
            corresponding value in position array. The input parameter position is an integer array of size batchSize.
            </summary>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
            <param name="position">integer array of size batchSize. The value of position(j) reports singularity
            of matrix Aj, -1 if no structural / numerical zero, k &gt;= 0 if Aj(k,k) is either structural zero or numerical zero.</param>
        </member>
        <member name="T:ManagedCuda.CudaSolve.CudaSolveSparse">
            <summary>
            CudaSolvSparse: The cuSolverSP library was mainly designed to a solve sparse linear system AxB and the least-squares problem
            x = argmin||A*z-b||
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.#ctor">
            <summary>
            Create new sparse solve instance
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.#ctor(ManagedCuda.CudaStream)">
            <summary>
            Create new sparse solve instance using stream stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.SetStream(ManagedCuda.CudaStream)">
            <summary>
            This function sets the stream to be used by the cuSolverSP library to execute its routines.
            </summary>
            <param name="stream">the stream to be used by the library.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.GetStream">
            <summary>
            This function gets the stream to be used by the cuSolverSP library to execute its routines.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrissymHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            This function checks if A has symmetric pattern or not. The output parameter issym
            reports 1 if A is symmetric; otherwise, it reports 0.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m elements that contains the start of every row.</param>
            <param name="csrEndPtrA">integer array of m elements that contains the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of matrix A.</param>
            <returns>1 if A is symmetric; 0 otherwise.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvluHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single,System.Int32,System.Single[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size n.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no ordering if reorder=0. Otherwise, symrcm is used to reduce zero fill-in.</param>
            <param name="x">solution vector of size n, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvluHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double,System.Int32,System.Double[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size n.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no ordering if reorder=0. Otherwise, symrcm is used to reduce zero fill-in.</param>
            <param name="x">solution vector of size n, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvluHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex[],System.Single,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size n.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no ordering if reorder=0. Otherwise, symrcm is used to reduce zero fill-in.</param>
            <param name="x">solution vector of size n, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvluHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex[],System.Double,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size n.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no ordering if reorder=0. Otherwise, symrcm is used to reduce zero fill-in.</param>
            <param name="x">solution vector of size n, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrlsvqr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrlsvqr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Single,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrlsvqr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Single,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrlsvqr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Single,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvqrHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single,System.Int32,System.Single[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvqrHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Single,System.Int32,System.Double[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvqrHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex[],System.Single,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvqrHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex[],System.Single,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide if singular or not.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvcholHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single,System.Int32,System.Single[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvcholHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Single,System.Int32,System.Double[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvcholHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex[],System.Single,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsvcholHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex[],System.Single,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex[])">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrlsvchol(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrlsvchol(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Single,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrlsvchol(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Single,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrlsvchol(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Single,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function solves the linear system A*x=b
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide singularity.</param>
            <param name="reorder">no effect.</param>
            <param name="x">solution vector of size m, x = inv(A)*b.</param>
            <returns>-1 if A is invertible. Otherwise, first index j such that U(j,j)≈0</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsqvqrHost(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Single[],System.Int32[],System.Int32[],System.Single[],System.Single,System.Int32@,System.Single[],System.Int32[],System.Single@)">
            <summary>
            This function solves the following least-square problem x = argmin||A*z-b||
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide rank of A.</param>
            <param name="rankA">numerical rank of A.</param>
            <param name="x">solution vector of size n, x=pinv(A)*b.</param>
            <param name="p">a vector of size n, which represents the permuation matrix P satisfying A*P^T=Q*R.</param>
            <param name="min_norm">||A*x-b||, x=pinv(A)*b.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsqvqrHost(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Double[],System.Int32[],System.Int32[],System.Double[],System.Double,System.Int32@,System.Double[],System.Int32[],System.Double@)">
            <summary>
            This function solves the following least-square problem x = argmin||A*z-b||
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide rank of A.</param>
            <param name="rankA">numerical rank of A.</param>
            <param name="x">solution vector of size n, x=pinv(A)*b.</param>
            <param name="p">a vector of size n, which represents the permuation matrix P satisfying A*P^T=Q*R.</param>
            <param name="min_norm">||A*x-b||, x=pinv(A)*b.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsqvqrHost(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex[],System.Single,System.Int32@,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Single@)">
            <summary>
            This function solves the following least-square problem x = argmin||A*z-b||
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide rank of A.</param>
            <param name="rankA">numerical rank of A.</param>
            <param name="x">solution vector of size n, x=pinv(A)*b.</param>
            <param name="p">a vector of size n, which represents the permuation matrix P satisfying A*P^T=Q*R.</param>
            <param name="min_norm">||A*x-b||, x=pinv(A)*b.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrlsqvqrHost(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex[],System.Double,System.Int32@,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Double@)">
            <summary>
            This function solves the following least-square problem x = argmin||A*z-b||
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="b">right hand side vector of size m.</param>
            <param name="tol">tolerance to decide rank of A.</param>
            <param name="rankA">numerical rank of A.</param>
            <param name="x">solution vector of size n, x=pinv(A)*b.</param>
            <param name="p">a vector of size n, which represents the permuation matrix P satisfying A*P^T=Q*R.</param>
            <param name="min_norm">||A*x-b||, x=pinv(A)*b.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsreigvsiHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Single[],System.Int32[],System.Int32[],System.Single,System.Single[],System.Int32,System.Single,System.Single@,System.Single[])">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsreigvsiHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Double[],System.Int32[],System.Int32[],System.Double,System.Double[],System.Int32,System.Double,System.Double@,System.Double[])">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsreigvsiHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32,System.Single,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.VectorTypes.cuFloatComplex[])">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsreigvsiHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32,System.Double,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.VectorTypes.cuDoubleComplex[])">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csreigvsi(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,System.Single@,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csreigvsi(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,System.Double@,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csreigvsi(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Single,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csreigvsi(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Double,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function solves the simple eigenvalue problem A*x=lambda*x by shift-inverse method.
            </summary>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="nnz">number of nonzeros of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(n) * csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="mu0">initial guess of eigenvalue.</param>
            <param name="x0">initial guess of eigenvector, a vecotr of size m.</param>
            <param name="maxite">maximum iterations in shift-inverse method.</param>
            <param name="tol">tolerance for convergence.</param>
            <param name="mu">approximated eigenvalue nearest mu0 under tolerance.</param>
            <param name="x">approximated eigenvector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsreigsHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Single[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.VectorTypes.cuFloatComplex,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsreigsHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Double[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.VectorTypes.cuDoubleComplex,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsreigsHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuFloatComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.VectorTypes.cuFloatComplex,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsreigsHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.VectorTypes.cuDoubleComplex[],System.Int32[],System.Int32[],ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.VectorTypes.cuDoubleComplex,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrsymrcmHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            This function implements Symmetric Reverse Cuthill-McKee permutation. It returns a
            permutation vector p such that A(p,p) would concentrate nonzeros to diagonal. This is
            equivalent to symrcm in MATLAB, however the result may not be the same because of
            different heuristics in the pseudoperipheral finder.
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">permutation vector of size n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrsymmdqHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Symmetric minimum degree algorithm based on quotient graph.<para/>
            This function implements Symmetric Minimum Degree Algorithm based on Quotient
            Graph. It returns a permutation vector p such that A(p,p) would have less zero fill-in
            during Cholesky factorization.
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">permutation vector of size n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrsymamdHost(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Symmetric Approximate minimum degree algorithm based on quotient graph.<para/>
            This function implements Symmetric Approximate Minimum Degree Algorithm based
            on Quotient Graph. It returns a permutation vector p such that A(p,p) would have less
            zero fill-in during Cholesky factorization.
            </summary>
            <param name="n">number of rows and columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">permutation vector of size n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.Csrperm_bufferSizeHost(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Given a left permutation vector p which corresponds to permutation matrix P and a
            right permutation vector q which corresponds to permutation matrix Q, this function
            computes permutation of matrix A by B = P*A*Q^T
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">left permutation vector of size m.</param>
            <param name="q">right permutation vector of size n.</param>
            <returns>number of bytes of the buffer.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrpermHost(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Byte[])">
            <summary>
            Given a left permutation vector p which corresponds to permutation matrix P and a
            right permutation vector q which corresponds to permutation matrix Q, this function
            computes permutation of matrix A by B = P*A*Q^T
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnzA">number of nonzeros of matrix A. It is the size of csrValA and csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of n + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (=csrRowPtrA(n) * csrRowPtrA(0)) column indices of the nonzero elements of matrix A.</param>
            <param name="p">left permutation vector of size m.</param>
            <param name="q">right permutation vector of size n.</param>
            <param name="map">integer array of nnzA indices. If the user wants to
            get relationship between A and B, map must be set 0:1:(nnzA-1).</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned by csrperm_bufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrAnalysisBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSolve.CsrQrInfo)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnzA">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="info">opaque structure for QR factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrBufferInfoBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSolve.CsrQrInfo,ManagedCuda.BasicTypes.SizeT@,ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="internalDataInBytes">number of bytes of the internal data.</param>
            <param name="workspaceInBytes">number of bytes of the buffer in numerical factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrBufferInfoBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSolve.CsrQrInfo,ManagedCuda.BasicTypes.SizeT@,ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="internalDataInBytes">number of bytes of the internal data.</param>
            <param name="workspaceInBytes">number of bytes of the buffer in numerical factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrBufferInfoBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSolve.CsrQrInfo,ManagedCuda.BasicTypes.SizeT@,ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="internalDataInBytes">number of bytes of the internal data.</param>
            <param name="workspaceInBytes">number of bytes of the buffer in numerical factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrBufferInfoBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSolve.CsrQrInfo,ManagedCuda.BasicTypes.SizeT@,ManagedCuda.BasicTypes.SizeT@)">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="internalDataInBytes">number of bytes of the internal data.</param>
            <param name="workspaceInBytes">number of bytes of the buffer in numerical factorization.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrsvBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaSolve.CsrQrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="b">array of m*batchSize of right-hand-side vectors b0, b1, .... All vectors are aggregated one after another.</param>
            <param name="x">array of m*batchSize of solution vectors x0, x1, .... All vectors are aggregated one after another.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned
            by cusolverSpXcsrqrBufferInfoBatched().</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrsvBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaSolve.CsrQrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="b">array of m*batchSize of right-hand-side vectors b0, b1, .... All vectors are aggregated one after another.</param>
            <param name="x">array of m*batchSize of solution vectors x0, x1, .... All vectors are aggregated one after another.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned
            by cusolverSpXcsrqrBufferInfoBatched().</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrsvBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaSolve.CsrQrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="b">array of m*batchSize of right-hand-side vectors b0, b1, .... All vectors are aggregated one after another.</param>
            <param name="x">array of m*batchSize of solution vectors x0, x1, .... All vectors are aggregated one after another.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned
            by cusolverSpXcsrqrBufferInfoBatched().</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveSparse.CsrqrsvBatched(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaSolve.CsrQrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            The batched sparse QR factorization is used to solve either a set of least-squares
            problems or a set of linear systems
            </summary>
            <param name="m">number of rows of each matrix Aj.</param>
            <param name="n">number of columns of each matrix Aj.</param>
            <param name="nnz">number of nonzeros of each matrix Aj. It is the size csrColIndA.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnzA*batchSize nonzero 
            elements of matrices A0, A1, .... All matrices are aggregated one after another.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzAcolumn indices of the nonzero elements of each matrix Aj.</param>
            <param name="b">array of m*batchSize of right-hand-side vectors b0, b1, .... All vectors are aggregated one after another.</param>
            <param name="x">array of m*batchSize of solution vectors x0, x1, .... All vectors are aggregated one after another.</param>
            <param name="batchSize">number of systems to be solved.</param>
            <param name="info">opaque structure for QR factorization.</param>
            <param name="pBuffer">buffer allocated by the user, the size is returned
            by cusolverSpXcsrqrBufferInfoBatched().</param>
        </member>
        <member name="T:ManagedCuda.CudaSolve.cusolverStatus">
            <summary>
            This is a status type returned by the library functions and it can have the following values.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.Success">
            <summary>
            The operation completed successfully
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.NotInititialized">
            <summary>
            The cuSolver library was not initialized. This is usually caused by the
            lack of a prior call, an error in the CUDA Runtime API called by the
            cuSolver routine, or an error in the hardware setup.<para/>
            To correct: call cusolverCreate() prior to the function call; and
            check that the hardware, an appropriate version of the driver, and the
            cuSolver library are correctly installed.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.AllocFailed">
            <summary>
            Resource allocation failed inside the cuSolver library. This is usually
            caused by a cudaMalloc() failure.<para/>
            To correct: prior to the function call, deallocate previously allocated
            memory as much as possible.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.InvalidValue">
            <summary>
            An unsupported value or parameter was passed to the function (a
            negative vector size, for example).<para/>
            To correct: ensure that all the parameters being passed have valid
            values.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.ArchMismatch">
            <summary>
            The function requires a feature absent from the device architecture;
            usually caused by the lack of support for atomic operations or double
            precision.<para/>
            To correct: compile and run the application on a device with compute
            capability 2.0 or above.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.MappingError">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.ExecutionFailed">
            <summary>
            The GPU program failed to execute. This is often caused by a launch
            failure of the kernel on the GPU, which can be caused by multiple
            reasons.<para/>
            To correct: check that the hardware, an appropriate version of the
            driver, and the cuSolver library are correctly installed.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.InternalError">
            <summary>
            An internal cuSolver operation failed. This error is usually caused by a
            cudaMemcpyAsync() failure.<para/>
            To correct: check that the hardware, an appropriate version of the
            driver, and the cuSolver library are correctly installed. Also, check
            that the memory passed as a parameter to the routine is not being
            deallocated prior to the routine’s completion.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.MatrixTypeNotSupported">
            <summary>
            The matrix type is not supported by this function. This is usually caused
            by passing an invalid matrix descriptor to the function.<para/>
            To correct: check that the fields in descrA were set correctly.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.NotSupported">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.ZeroPivot">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverStatus.InvalidLicense">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.cusolverEigType">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverEigType.Type1">
            <summary/>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverEigType.Type2">
            <summary/>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverEigType.Type3">
            <summary/>
        </member>
        <member name="T:ManagedCuda.CudaSolve.cusolverEigMode">
            <summary>
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverEigMode.NoVector">
            <summary/>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverEigMode.Vector">
            <summary/>
        </member>
        <member name="T:ManagedCuda.CudaSolve.cusolverDnHandle">
            <summary>
            This is a pointer type to an opaque cuSolverDN context
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverDnHandle.Pointer">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.cusolverSpHandle">
            <summary>
            This is a pointer type to an opaque cuSolverSP context
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverSpHandle.Pointer">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.csrqrInfo">
            <summary>
            This is a pointer type to an opaque csrqrInfo
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.csrqrInfo.Pointer">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.cusolverRfHandle">
            <summary>
            This is a pointer type to an opaque cuSolverRF context
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.cusolverRfHandle.Pointer">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.ResetValuesFastMode">
            <summary>
            The ResetValuesFastMode is an enum that indicates the mode used for
            the cusolverRfResetValues() routine. The fast mode requires extra memory and is
            recommended only if very fast calls to cusolverRfResetValues() are needed.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.ResetValuesFastMode.Off">
            <summary>
            default
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.ResetValuesFastMode.On">
            <summary/>  
        </member>
        <member name="T:ManagedCuda.CudaSolve.MatrixFormat">
            <summary>
            The MatrixFormat is an enum that indicates the input/output
            matrix format assumed by the cusolverRfSetup(), cusolverRfSetupHost(),
            cusolverRfResetValues(), cusolveRfExtractBundledFactorsHost() and
            cusolverRfExtractSplitFactorsHost() routines.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.MatrixFormat.Csr">
            <summary>
            default
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.MatrixFormat.Csc">
            <summary/>
        </member>
        <member name="T:ManagedCuda.CudaSolve.UnitDiagonal">
            <summary>
            The UnitDiagonal is an enum that indicates whether
            and where the unit diagonal is stored in the input/output triangular
            factors in the cusolverRfSetup(), cusolverRfSetupHost() and
            cusolverRfExtractSplitFactorsHost() routines.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.UnitDiagonal.StoredL">
            <summary>
            unit diagonal is stored in lower triangular factor. (default)
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.UnitDiagonal.StoredU">
            <summary>
            unit diagonal is stored in upper triangular factor.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.UnitDiagonal.AssumedL">
            <summary>
            unit diagonal is assumed in lower triangular factor.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.UnitDiagonal.AssumedU">
            <summary>
            unit diagonal is assumed in upper triangular factor.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.Factorization">
            <summary>
            The Factorization is an enum that indicates which (internal)
            algorithm is used for refactorization in the cusolverRfRefactor() routine.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.Factorization.Alg0">
            <summary>
            algorithm 0. (default)
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.Factorization.Alg1">
            <summary>
            algorithm 1.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.Factorization.Alg2">
            <summary>
            algorithm 2. Domino-based scheme.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.TriangularSolve">
            <summary>
            The TriangularSolve is an enum that indicates which (internal)
            algorithm is used for triangular solve in the cusolverRfSolve() routine.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.TriangularSolve.Alg0">
            <summary>
            algorithm 0.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.TriangularSolve.Alg1">
            <summary>
            algorithm 1. (default)
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.TriangularSolve.Alg2">
            <summary>
            algorithm 2. Domino-based scheme.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.TriangularSolve.Alg3">
            <summary>
            algorithm 3. Domino-based scheme.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSolve.NumericBoostReport">
            <summary>
            The cusolverRfNumericBoostReport_t is an enum that indicates whether
            numeric boosting (of the pivot) was used during the cusolverRfRefactor() and
            cusolverRfSolve() routines. The numeric boosting is disabled by default.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.NumericBoostReport.NotUsed">
            <summary>
            default
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSolve.NumericBoostReport.Used">
            <summary/>
        </member>
        <member name="T:ManagedCuda.CudaSolve.CudaSolveRefactorization">
            <summary>
            CudaSolveRefactorization: The cuSolverRF library was designed to accelerate solution of sets of linear systems by
            fast re-factorization when given new coefficients in the same sparsity pattern
            A_i x_i = f_i
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.#ctor">
            <summary>
            Create new refactorization solve instance
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.GetMatrixFormat(ManagedCuda.CudaSolve.MatrixFormat@,ManagedCuda.CudaSolve.UnitDiagonal@)">
            <summary>
            This routine gets the matrix format used in the cusolverRfSetup(),
            cusolverRfSetupHost(), cusolverRfResetValues(), cusolverRfExtractBundledFactorsHost() and cusolverRfExtractSplitFactorsHost() routines.
            </summary>
            <param name="format">the enumerated matrix format type.</param>
            <param name="diag">the enumerated unit diagonal type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.SetMatrixFormat(ManagedCuda.CudaSolve.MatrixFormat,ManagedCuda.CudaSolve.UnitDiagonal)">
            <summary>
            This routine sets the matrix format used in the cusolverRfSetup(),
            cusolverRfSetupHost(), cusolverRfResetValues(), cusolverRfExtractBundledFactorsHost() and cusolverRfExtractSplitFactorsHost() routines.
            </summary>
            <param name="format">the enumerated matrix format type.</param>
            <param name="diag">the enumerated unit diagonal type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.SetNumericProperties(System.Double,System.Double)">
            <summary>
            This routine sets the numeric values used for checking for "zero" pivot and for boosting
            it in the cusolverRfRefactor() and cusolverRfSolve() routines. It may be called 
            multiple times prior to cusolverRfRefactor() and cusolverRfSolve() routines.
            The numeric boosting will be used only if boost &gt; 0.0.
            </summary>
            <param name="zero">the value below which zero pivot is flagged.</param>
            <param name="boost">the value which is substituted for zero pivot (if the later is flagged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.GetNumericProperties(System.Double@,System.Double@)">
            <summary>
            This routine gets the numeric values used for checking for "zero" pivot and for boosting
            it in the cusolverRfRefactor() and cusolverRfSolve() routines. It may be called 
            multiple times prior to cusolverRfRefactor() and cusolverRfSolve() routines.
            The numeric boosting will be used only if boost &gt; 0.0.
            </summary>
            <param name="zero">the value below which zero pivot is flagged.</param>
            <param name="boost">the value which is substituted for zero pivot (if the later is flagged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.GetNumericBoostReport(ManagedCuda.CudaSolve.NumericBoostReport@)">
            <summary>
            This routine gets the report whether numeric boosting was used in the
            cusolverRfRefactor() and cusolverRfSolve() routines.
            </summary>
            <param name="report">the enumerated boosting report type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.SetAlgs(ManagedCuda.CudaSolve.Factorization,ManagedCuda.CudaSolve.TriangularSolve)">
            <summary>
            This routine sets the algorithm used for the refactorization in cusolverRfRefactor()
            and the triangular solve in cusolverRfSolve(). It may be called once prior to
            cusolverRfAnalyze() routine.
            </summary>
            <param name="factAlg">the enumerated algorithm type.</param>
            <param name="solveAlg">the enumerated algorithm type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.GetAlgs(ManagedCuda.CudaSolve.Factorization@,ManagedCuda.CudaSolve.TriangularSolve@)">
            <summary>
            This routine gets the algorithm used for the refactorization in cusolverRfRefactor()
            and the triangular solve in cusolverRfSolve(). It may be called once prior to
            cusolverRfAnalyze() routine.
            </summary>
            <param name="factAlg">the enumerated algorithm type.</param>
            <param name="solveAlg">the enumerated algorithm type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.GetResetValuesFastMode(ManagedCuda.CudaSolve.ResetValuesFastMode@)">
            <summary>
            This routine gets the mode used in the cusolverRfResetValues routine.
            </summary>
            <param name="fastMode">the enumerated mode type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.SetResetValuesFastMode(ManagedCuda.CudaSolve.ResetValuesFastMode)">
            <summary>
            This routine sets the mode used in the cusolverRfResetValues routine.
            </summary>
            <param name="fastMode">the enumerated mode type.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.SetupHost(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[])">
            <summary>This routine assembles the internal data structures of the cuSolverRF library. It is often
            the first routine to be called after the call to the cusolverRfCreate() routine.
            </summary>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="h_csrRowPtrA">the array of offsets corresponding to 
            the start of each row in the arrays h_csrColIndA and h_csrValA. This
            array has also an extra entry at the end that stores the number of non-zero
            elements in the matrix. The array size is n+1.</param>
            <param name="h_csrColIndA">the array of column indices corresponding
            to the non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="h_csrValA">the array of values corresponding to the
            non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="nnzL">the number of non-zero elements of matrix L.</param>
            <param name="h_csrRowPtrL">the array of offsets corresponding to
            the start of each row in the arrays h_csrColIndL and h_csrValL. This
            array has also an extra entry at the end that stores the number of non-zero
            elements in the matrix L. The array size is n+1.</param>
            <param name="h_csrColIndL">the array of column indices corresponding
            to the non-zero elements in the matrix L. It is assumed that this array is sorted by
            row and by column within each row. The array size is nnzL.</param>
            <param name="h_csrValL">the array of values corresponding to the
            non-zero elements in the matrix L. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzL.</param>
            <param name="nnzU">the number of non-zero elements of matrix U.</param>
            <param name="h_csrRowPtrU">the array of offsets corresponding to
            the start of each row in the arrays h_csrColIndU and h_csrValU. This
            array has also an extra entry at the end that stores the number of non-zero elements in the matrix U. The array size is n+1.</param>
            <param name="h_csrColIndU">the array of column indices corresponding 
            to the non-zero elements in the matrix U. It is assumed that this array is sorted by row and by column within each row. The array size is nnzU.</param>
            <param name="h_csrValU">the array of values corresponding to the non-zero elements in the matrix U. It is
            assumed that this array is sorted by row and by column within each row. The array size is nnzU.</param>
            <param name="h_P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="h_Q">the right permutation (often associated with reordering). The array size in n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.cusolverRfSetupDevice(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>This routine assembles the internal data structures of the cuSolverRF library. It is often
            the first routine to be called after the call to the cusolverRfCreate() routine.
            </summary>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">the array of offsets corresponding to 
            the start of each row in the arrays h_csrColIndA and h_csrValA. This
            array has also an extra entry at the end that stores the number of non-zero
            elements in the matrix. The array size is n+1.</param>
            <param name="csrColIndA">the array of column indices corresponding
            to the non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="csrValA">the array of values corresponding to the
            non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="nnzL">the number of non-zero elements of matrix L.</param>
            <param name="csrRowPtrL">the array of offsets corresponding to
            the start of each row in the arrays h_csrColIndL and h_csrValL. This
            array has also an extra entry at the end that stores the number of non-zero
            elements in the matrix L. The array size is n+1.</param>
            <param name="csrColIndL">the array of column indices corresponding
            to the non-zero elements in the matrix L. It is assumed that this array is sorted by
            row and by column within each row. The array size is nnzL.</param>
            <param name="csrValL">the array of values corresponding to the
            non-zero elements in the matrix L. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzL.</param>
            <param name="nnzU">the number of non-zero elements of matrix U.</param>
            <param name="csrRowPtrU">the array of offsets corresponding to
            the start of each row in the arrays h_csrColIndU and h_csrValU. This
            array has also an extra entry at the end that stores the number of non-zero elements in the matrix U. The array size is n+1.</param>
            <param name="csrColIndU">the array of column indices corresponding 
            to the non-zero elements in the matrix U. It is assumed that this array is sorted by row and by column within each row. The array size is nnzU.</param>
            <param name="csrValU">the array of values corresponding to the non-zero elements in the matrix U. It is
            assumed that this array is sorted by row and by column within each row. The array size is nnzU.</param>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.ResetValues(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This routine updates internal data structures with the values of the new coefficient
            matrix. It is assumed that the arrays csrRowPtrA, csrColIndA, P and Q have not
            changed since the last call to the cusolverRfSetup[Host] routine. This assumption
            reflects the fact that the sparsity pattern of coefficient matrices as well as reordering to
            minimize fill-in and pivoting remain the same in the set of linear systems
            </summary>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">the array of offsets corresponding to the start of each row in the arrays
            csrColIndA and csrValA. This array has also an extra entry at the end that stores the number of non-zero elements in the
            matrix. The array size is n+1.</param>
            <param name="csrColIndA">the array of column indices corresponding to the non-zero elements in the matrix. It
            is assumed that this array is sorted by row and by column within each row. The array size is nnzA.</param>
            <param name="csrValA">the array of values corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.Analyze">
            <summary>
            This routine performs the appropriate analysis of parallelism available in the LU refactorization depending upon the algorithm chosen by the user.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.Refactor(ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine performs the LU re-factorization
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.AccessBundledFactorsDevice(System.Int32@,ManagedCuda.CudaDeviceVariable{System.Int32}@,ManagedCuda.CudaDeviceVariable{System.Int32}@,ManagedCuda.CudaDeviceVariable{System.Double}@)">
            <summary>
            This routine allows direct access to the lower L and upper U triangular factors stored in
            the cuSolverRF library handle. The factors are compressed into a single matrix M=(LI)+
            U, where the unitary diagonal of L is not stored. It is assumed that a prior call to the
            cusolverRfRefactor() was done in order to generate these triangular factors.
            </summary>
            <param name="nnzM">the number of non-zero elements of matrix M.</param>
            <param name="Mp">the array of offsets corresponding to the start of each row in the arrays Mi and Mx.
            This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.</param>
            <param name="Mi">the array of column indices corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.</param>
            <param name="Mx">the array of values corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.ExtractBundledFactorsHost(System.Int32,System.Int32@,System.Int32[]@,System.Int32[]@,System.Double[]@)">
            <summary>
            This routine allows direct access to the lower L and upper U triangular factors stored in
            the cuSolverRF library handle. The factors are compressed into a single matrix M=(LI)+
            U, where the unitary diagonal of L is not stored. It is assumed that a prior call to the
            cusolverRfRefactor() was done in order to generate these triangular factors.
            </summary>
            <param name="n">Size of Matrix M (n x n)</param>
            <param name="h_nnzM">the number of non-zero elements of matrix M.</param>
            <param name="h_Mp">the array of offsets corresponding to the start of each row in the arrays Mi and Mx.
            This array has also an extra entry at the end that stores the number of non-zero elements in the matrix $M$. The array size is n+1.</param>
            <param name="h_Mi">the array of column indices corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.</param>
            <param name="h_Mx">the array of values corresponding to the non-zero elements in the matrix M. It is assumed that this array is sorted by row and by column within each row. The array size is nnzM.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.ExtractSplitFactorsHost(System.Int32,System.Int32@,System.Int32[]@,System.Int32[]@,System.Double[]@,System.Int32@,System.Int32[]@,System.Int32[]@,System.Double[]@)">
            <summary>
            This routine extracts lower (L) and upper (U) triangular factors from the
            cuSolverRF library handle into the host memory. It is assumed that a prior call to the
            cusolverRfRefactor() was done in order to generate these triangular factors.
            </summary>
            <param name="n">Size of Matrix M (n x n)</param>
            <param name="h_nnzL">the number of non-zero elements of matrix L.</param>
            <param name="h_csrRowPtrL">the array of offsets corresponding to the start of each row in the arrays h_Li and
            h_Lx. This array has also an extra entry at the end that stores the number of nonzero elements in the matrix L. The array size is n+1.</param>
            <param name="h_csrColIndL">the array of column indices corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by
            row and by column within each row. The array size is h_nnzL.</param>
            <param name="h_csrValL">the array of values corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by row
            and by column within each row. The array size is h_nnzL.</param>
            <param name="h_nnzU">the number of non-zero elements of matrix U.</param>
            <param name="h_csrRowPtrU">the array of offsets corresponding to the start of each row in the arrays h_Ui and h_Ux. This array has also an extra entry
            at the end that stores the number of nonzero elements in the matrix U. The array size is n+1.</param>
            <param name="h_csrColIndU">the array of column indices corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by
            row and by column within each row. The array size is h_nnzU.</param>
            <param name="h_csrValU">the array of values corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by row
            and by column within each row. The array size is h_nnzU.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.Solve(ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Double[],System.Int32,System.Double[],System.Int32)">
            <summary>
            This routine performs the forward and backward solve with the lower and upper
            triangular factors resulting from the LU re-factorization
            </summary>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="nrhs">the number right-hand-sides to be solved.</param>
            <param name="Temp">the dense matrix that contains temporary workspace (of size ldt*nrhs).</param>
            <param name="ldt">the leading dimension of dense matrix Temp (ldt &gt;= n).</param>
            <param name="XF">the dense matrix that contains the righthand-sides F and solutions X (of size ldxf*nrhs).</param>
            <param name="ldxf">the leading dimension of dense matrix XF (ldxf &gt;= n).</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.BatchSetupHost(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[][],System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32,System.Int32[],System.Int32[],System.Double[],System.Int32[],System.Int32[],ManagedCuda.CudaSolve.cusolverRfHandle)">
            <summary>
            This routine assembles the internal data structures of the cuSolverRF library for batched
            operation. It is called after the call to the cusolverRfCreate() routine, and before any
            other batched routines.
            </summary>
            <param name="batchSize">the number of matrices in the batched mode.</param>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="h_csrRowPtrA">the array of offsets corresponding to 
            the start of each row in the arrays h_csrColIndA and h_csrValA. This array has also an extra entry at the
            end that stores the number of non-zero elements in the matrix. The array size is n+1.</param>
            <param name="h_csrColIndA">the array of column indices corresponding 
            to the non-zero elements in the matrix. It is assumed that this array is sorted by row and by column within each row. The array size is nnzA.</param>
            <param name="h_csrValA_array">array of pointers of size batchSize, each pointer points to the array of values corresponding to the non-zero elements in the matrix.</param>
            <param name="nnzL">the number of non-zero elements of matrix L.</param>
            <param name="h_csrRowPtrL">the array of offsets corresponding to the start of each row in the arrays h_csrColIndL and h_csrValL. This
            array has also an extra entry at the end that stores the number of non-zero elements in the matrix L. The array size is n+1.</param>
            <param name="h_csrColIndL">the array of column indices corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by
            row and by column within each row. The array size is nnzL.</param>
            <param name="h_csrValL">the array of values corresponding to the non-zero elements in the matrix L. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzL.</param>
            <param name="nnzU">the number of non-zero elements of matrix U.</param>
            <param name="h_csrRowPtrU">the array of offsets corresponding to the start of each row in the arrays h_csrColIndU and h_csrValU. This
            array has also an extra entry at the end that stores the number of non-zero elements in the matrix U. The array size is n+1.</param>
            <param name="h_csrColIndU">the array of column indices corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by
            row and by column within each row. The array size is nnzU.</param> 
            <param name="h_csrValU">the array of values corresponding to the non-zero elements in the matrix U. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzU.</param>
            <param name="h_P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="h_Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="handle">the pointer to the cuSolverRF library handle.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.BatchResetValues(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double}[],ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine updates internal data structures with the values of the new coefficient
            matrix. It is assumed that the arrays csrRowPtrA, csrColIndA, P and Q have not 
            changed since the last call to the cusolverRfbatch_setup_host routine.
            </summary>
            <param name="batchSize">the number of matrices in batched mode.</param>
            <param name="n">the number of rows (and columns) of matrix A.</param>
            <param name="nnzA">the number of non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">the array of offsets corresponding to the start of each row in the arrays csrColIndA and csrValA. 
            This array has also an extra entry at the end that stores the number of non-zero elements in the matrix. The array size is n+1.</param>
            <param name="csrColIndA">the array of column indices corresponding to the non-zero elements in the matrix. It is assumed that this array is sorted by row
            and by column within each row. The array size is nnzA.</param>
            <param name="csrValA_array">array of pointers of size batchSize, each pointer points to the array of values corresponding to the non-zero elements in the matrix.</param>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.BatchAnalyze">
            <summary>
            This routine performs the appropriate analysis of parallelism available in the batched LU re-factorization.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.BatchRefactor">
            <summary>
            This routine performs the LU re-factorization
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.cusolverRfBatchSolve(ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Double[],System.Int32,System.Double[][],System.Int32)">
            <summary>
            To solve A_j * x_j = b_j, first we reform the equation by M_j * Q * x_j = P * b_j. Then do refactorization by
            cusolverRfBatch_Refactor(). Further cusolverRfBatch_Solve() takes over the remaining steps.
            </summary>
            <param name="P">the left permutation (often associated with pivoting). The array size in n.</param>
            <param name="Q">the right permutation (often associated with reordering). The array size in n.</param>
            <param name="nrhs">the number right-hand-sides to be solved.</param>
            <param name="Temp">the dense matrix that contains temporary workspace (of size ldt*nrhs).</param>
            <param name="ldt">the leading dimension of dense matrix Temp (ldt &gt;= n).</param>
            <param name="XF_array">array of pointers of size batchSize, each pointer points to the dense matrix that contains the right-hand-sides F and solutions X (of size ldxf*nrhs).</param>
            <param name="ldxf">the leading dimension of dense matrix XF (ldxf &gt;= n).</param>
        </member>
        <member name="M:ManagedCuda.CudaSolve.CudaSolveRefactorization.BatchZeroPivot(System.Int32[])">
            <summary>
            The user can query which matrix failed LU refactorization by checking
            corresponding value in position array. The input parameter position is an integer array of size batchSize.
            </summary>
            <param name="position">integer array of size batchSize. The value of position(j) reports singularity
            of matrix Aj, -1 if no structural / numerical zero, k &gt;= 0 if Aj(k,k) is either structural zero or numerical zero.</param>
        </member>
    </members>
</doc>
