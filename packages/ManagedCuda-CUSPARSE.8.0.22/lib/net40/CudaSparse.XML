<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CudaSparse</name>
    </assembly>
    <members>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseBsrsm2Info">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrsm2Info.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrsm2Info.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrsm2Info.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrsm2Info.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseBsrsm2Info.Bsrsm2Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseColorInfo">
            <summary>
            Wrapper class for cusparseColorInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseColorInfo.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseColorInfo.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseColorInfo.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseColorInfo.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseColorInfo.SetColorAlgs(ManagedCuda.CudaSparse.cusparseColorAlg)">
            <summary>
            SetColorAlgs
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseColorInfo.GetColorAlgs">
            <summary>
            GetColorAlgs
            </summary>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseColorInfo.ColorInfo">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseContext">
            <summary>
            Wrapper class for cusparseContext. Provides all fundamental API functions as methods.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.#ctor">
            <summary>
            Creates a new CudaSparseContext
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.#ctor(ManagedCuda.BasicTypes.CUstream)">
            <summary>
            Creates a new CudaSparseContext and sets the cuda stream to use
            </summary>
            <param name="stream">A valid CUDA stream created with cudaStreamCreate() (or 0 for the default stream)</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.SetStream(ManagedCuda.BasicTypes.CUstream)">
            <summary>
            Sets the cuda stream to use
            </summary>
            <param name="stream">A valid CUDA stream created with cudaStreamCreate() (or 0 for the default stream)</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GetStream">
            <summary>
            Gets the cuda stream to use
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GetVersion">
            <summary>
            Returns the version of the underlying CUSPARSE library
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GetPointerMode">
            <summary>
            Returns the pointer mode for scalar values (host or device pointer)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.SetPointerMode(ManagedCuda.CudaSparse.cusparsePointerMode)">
            <summary>
            Sets the pointer mode for scalar values (host or device pointer)
            </summary>
            <param name="pointerMode"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GetLevelInfo(ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,System.Int32@,ManagedCuda.CudaDeviceVariable{System.Int32}@,ManagedCuda.CudaDeviceVariable{System.Int32}@)">
            <summary>
            This function returns the number of levels and the assignment of rows into the levels
            computed by either the csrsv_analysis, csrsm_analysis or hybsv_analysis routines.
            </summary>
            <param name="info">the pointer to the solve and analysis structure.</param>
            <param name="nLevels">number of levels.</param>
            <param name="levelPtr">integer array of nlevels+1 elements that contains
            the start of every level and the end of the last
            level plus one.</param>
            <param name="levelIdx">integer array of m (number of rows in the matrix)
            elements that contains the row indices belonging
            to every level.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(System.Single,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(System.Double,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Double@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dotci(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of complex conjugate of a sparse vector x and a dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dotci(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of complex conjugate of a sparse vector x and a dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dotci(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of complex conjugate of a sparse vector x and a dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dotci(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of complex conjugate of a sparse vector x and a dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthr(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from dense vector y into sparse vector x.
            </summary>
            <param name="y">vector in dense format (of size >= max(xInd)-idxBase+1).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthr(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from dense vector y into sparse vector x.
            </summary>
            <param name="y">vector in dense format (of size >= max(xInd)-idxBase+1).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthr(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from dense vector y into sparse vector x.
            </summary>
            <param name="y">vector in dense format (of size >= max(xInd)-idxBase+1).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthr(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from dense vector y into sparse vector x.
            </summary>
            <param name="y">vector in dense format (of size >= max(xInd)-idxBase+1).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthrz(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from desne vector y into sparse vector x (also replacing these elements in y by zeros).
            </summary>
            <param name="y">vector in dense format with elements indexed by xInd set to zero (it is unchanged if nnz == 0).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthrz(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from desne vector y into sparse vector x (also replacing these elements in y by zeros).
            </summary>
            <param name="y">vector in dense format with elements indexed by xInd set to zero (it is unchanged if nnz == 0).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthrz(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from desne vector y into sparse vector x (also replacing these elements in y by zeros).
            </summary>
            <param name="y">vector in dense format with elements indexed by xInd set to zero (it is unchanged if nnz == 0).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthrz(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from desne vector y into sparse vector x (also replacing these elements in y by zeros).
            </summary>
            <param name="y">vector in dense format with elements indexed by xInd set to zero (it is unchanged if nnz == 0).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Sctr(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Scatter of elements of the sparse vector x into dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Sctr(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Scatter of elements of the sparse vector x into dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Sctr(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Scatter of elements of the sparse vector x into dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Sctr(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Scatter of elements of the sparse vector x into dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Roti(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single,System.Single,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Givens rotation, where c and s are cosine and sine, x and y are sparse and dense vectors, respectively.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="c">cosine element of the rotation matrix.</param>
            <param name="s">sine element of the rotation matrix.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Roti(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Double,System.Double,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Givens rotation, where c and s are cosine and sine, x and y are sparse and dense vectors, respectively.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="c">cosine element of the rotation matrix.</param>
            <param name="s">sine element of the rotation matrix.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Roti(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Givens rotation, where c and s are cosine and sine, x and y are sparse and dense vectors, respectively.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="c">cosine element of the rotation matrix.</param>
            <param name="s">sine element of the rotation matrix.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Roti(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Givens rotation, where c and s are cosine and sine, x and y are sparse and dense vectors, respectively.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="c">cosine element of the rotation matrix.</param>
            <param name="s">sine element of the rotation matrix.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrmvMP(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            Using a Merge Path load-balancing implementation.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrmvMP(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Double,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            Using a Merge Path load-balancing implementation.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrmvMP(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            Using a Merge Path load-balancing implementation.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrmvMP(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            Using a Merge Path load-balancing implementation.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrmvMP(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            Using a Merge Path load-balancing implementation.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrmvMP(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            Using a Merge Path load-balancing implementation.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrmvMP(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            Using a Merge Path load-balancing implementation.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrmvMP(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            Using a Merge Path load-balancing implementation.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemvi(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + B * y <para/>
            A is an m x n dense matrix and a sparse vector x that is defined in a sparse storage format
            by the two arrays xVal, xInd of length nnz, and y is a dense vector; alpha and beta are scalars.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">the pointer to dense matrix A.</param>
            <param name="lda">size of the leading dimension of A.</param>
            <param name="nnz">number of nonzero elements of vector x.</param>
            <param name="xVal">sparse vector of nnz elements of size n if op(A) = A, and of size m if op(A) = A^T or op(A) = A^H</param>
            <param name="xInd">Indices of non-zero values in x</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">dense vector of m elements if op(A) = A, and of n elements if op(A) = A^T or op(A) = A^H</param>
            <param name="idxBase">0 or 1, for 0 based or 1 based indexing, respectively</param>
            <param name="pBuffer">working space buffer, of size given by Xgemvi_getBufferSize()</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemvi(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + B * y <para/>
            A is an m x n dense matrix and a sparse vector x that is defined in a sparse storage format
            by the two arrays xVal, xInd of length nnz, and y is a dense vector; alpha and beta are scalars.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">the pointer to dense matrix A.</param>
            <param name="lda">size of the leading dimension of A.</param>
            <param name="nnz">number of nonzero elements of vector x.</param>
            <param name="xVal">sparse vector of nnz elements of size n if op(A) = A, and of size m if op(A) = A^T or op(A) = A^H</param>
            <param name="xInd">Indices of non-zero values in x</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">dense vector of m elements if op(A) = A, and of n elements if op(A) = A^T or op(A) = A^H</param>
            <param name="idxBase">0 or 1, for 0 based or 1 based indexing, respectively</param>
            <param name="pBuffer">working space buffer, of size given by Xgemvi_getBufferSize()</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemvi(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + B * y <para/>
            A is an m x n dense matrix and a sparse vector x that is defined in a sparse storage format
            by the two arrays xVal, xInd of length nnz, and y is a dense vector; alpha and beta are scalars.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">the pointer to dense matrix A.</param>
            <param name="lda">size of the leading dimension of A.</param>
            <param name="nnz">number of nonzero elements of vector x.</param>
            <param name="xVal">sparse vector of nnz elements of size n if op(A) = A, and of size m if op(A) = A^T or op(A) = A^H</param>
            <param name="xInd">Indices of non-zero values in x</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">dense vector of m elements if op(A) = A, and of n elements if op(A) = A^T or op(A) = A^H</param>
            <param name="idxBase">0 or 1, for 0 based or 1 based indexing, respectively</param>
            <param name="pBuffer">working space buffer, of size given by Xgemvi_getBufferSize()</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemvi(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + B * y <para/>
            A is an m x n dense matrix and a sparse vector x that is defined in a sparse storage format
            by the two arrays xVal, xInd of length nnz, and y is a dense vector; alpha and beta are scalars.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">the pointer to dense matrix A.</param>
            <param name="lda">size of the leading dimension of A.</param>
            <param name="nnz">number of nonzero elements of vector x.</param>
            <param name="xVal">sparse vector of nnz elements of size n if op(A) = A, and of size m if op(A) = A^T or op(A) = A^H</param>
            <param name="xInd">Indices of non-zero values in x</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">dense vector of m elements if op(A) = A, and of n elements if op(A) = A^T or op(A) = A^H</param>
            <param name="idxBase">0 or 1, for 0 based or 1 based indexing, respectively</param>
            <param name="pBuffer">working space buffer, of size given by Xgemvi_getBufferSize()</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemvi(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + B * y <para/>
            A is an m x n dense matrix and a sparse vector x that is defined in a sparse storage format
            by the two arrays xVal, xInd of length nnz, and y is a dense vector; alpha and beta are scalars.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">the pointer to dense matrix A.</param>
            <param name="lda">size of the leading dimension of A.</param>
            <param name="nnz">number of nonzero elements of vector x.</param>
            <param name="xVal">sparse vector of nnz elements of size n if op(A) = A, and of size m if op(A) = A^T or op(A) = A^H</param>
            <param name="xInd">Indices of non-zero values in x</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">dense vector of m elements if op(A) = A, and of n elements if op(A) = A^T or op(A) = A^H</param>
            <param name="idxBase">0 or 1, for 0 based or 1 based indexing, respectively</param>
            <param name="pBuffer">working space buffer, of size given by Xgemvi_getBufferSize()</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemvi(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + B * y <para/>
            A is an m x n dense matrix and a sparse vector x that is defined in a sparse storage format
            by the two arrays xVal, xInd of length nnz, and y is a dense vector; alpha and beta are scalars.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">the pointer to dense matrix A.</param>
            <param name="lda">size of the leading dimension of A.</param>
            <param name="nnz">number of nonzero elements of vector x.</param>
            <param name="xVal">sparse vector of nnz elements of size n if op(A) = A, and of size m if op(A) = A^T or op(A) = A^H</param>
            <param name="xInd">Indices of non-zero values in x</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">dense vector of m elements if op(A) = A, and of n elements if op(A) = A^T or op(A) = A^H</param>
            <param name="idxBase">0 or 1, for 0 based or 1 based indexing, respectively</param>
            <param name="pBuffer">working space buffer, of size given by Xgemvi_getBufferSize()</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemvi(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + B * y <para/>
            A is an m x n dense matrix and a sparse vector x that is defined in a sparse storage format
            by the two arrays xVal, xInd of length nnz, and y is a dense vector; alpha and beta are scalars.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">the pointer to dense matrix A.</param>
            <param name="lda">size of the leading dimension of A.</param>
            <param name="nnz">number of nonzero elements of vector x.</param>
            <param name="xVal">sparse vector of nnz elements of size n if op(A) = A, and of size m if op(A) = A^T or op(A) = A^H</param>
            <param name="xInd">Indices of non-zero values in x</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">dense vector of m elements if op(A) = A, and of n elements if op(A) = A^T or op(A) = A^H</param>
            <param name="idxBase">0 or 1, for 0 based or 1 based indexing, respectively</param>
            <param name="pBuffer">working space buffer, of size given by Xgemvi_getBufferSize()</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemvi(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + B * y <para/>
            A is an m x n dense matrix and a sparse vector x that is defined in a sparse storage format
            by the two arrays xVal, xInd of length nnz, and y is a dense vector; alpha and beta are scalars.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="A">the pointer to dense matrix A.</param>
            <param name="lda">size of the leading dimension of A.</param>
            <param name="nnz">number of nonzero elements of vector x.</param>
            <param name="xVal">sparse vector of nnz elements of size n if op(A) = A, and of size m if op(A) = A^T or op(A) = A^H</param>
            <param name="xInd">Indices of non-zero values in x</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">dense vector of m elements if op(A) = A, and of n elements if op(A) = A^T or op(A) = A^H</param>
            <param name="idxBase">0 or 1, for 0 based or 1 based indexing, respectively</param>
            <param name="pBuffer">working space buffer, of size given by Xgemvi_getBufferSize()</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GemviSBufferSize(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in gemvi(). A is an (m)x(n) dense matrix.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix Y.</param>
            <param name="nnz">number of nonzero entries of vector x multiplying A.</param>
            <returns>number of elements needed the buffer used in gemvi().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GemviDBufferSize(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in gemvi(). A is an (m)x(n) dense matrix.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix Y.</param>
            <param name="nnz">number of nonzero entries of vector x multiplying A.</param>
            <returns>number of elements needed the buffer used in gemvi().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GemviCBufferSize(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in gemvi(). A is an (m)x(n) dense matrix.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix Y.</param>
            <param name="nnz">number of nonzero entries of vector x multiplying A.</param>
            <returns>number of elements needed the buffer used in gemvi().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GemviZBufferSize(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in gemvi(). A is an (m)x(n) dense matrix.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix Y.</param>
            <param name="nnz">number of nonzero entries of vector x multiplying A.</param>
            <returns>number of elements needed the buffer used in gemvi().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Double,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},System.Single,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},System.Double,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvAnalysis``1(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <typeparam name="T">data type: float, double, cuFloatComplex or cuDoubleComplex</typeparam>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type 
            CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2ZeroPivot(ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXcsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called csrsv2_analysis() or csrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2ZeroPivot(ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,System.Int32@)">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXcsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called csrsv2_analysis() or csrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2BufferSize(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info)">
            <summary>
            This function returns the size of the buffer used in csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2BufferSize(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info)">
            <summary>
            This function returns the size of the buffer used in csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2BufferSize(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info)">
            <summary>
            This function returns the size of the buffer used in csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2BufferSize(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info)">
            <summary>
            This function returns the size of the buffer used in csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Analysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Analysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Analysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Analysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Single@,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the solve phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Double@,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the solve phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the solve phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the solve phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the solve phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the solve phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the solve phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrsv2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the solve phase of csrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2ZeroPivot(ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXbsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called bsrsv2_analysis() or bsrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2ZeroPivot(ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,System.Int32@)">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXbsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called bsrsv2_analysis() or bsrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2BufferSize(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info)">
            <summary>
            This function returns the size of the buffer used in bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2BufferSize(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info)">
            <summary>
            This function returns the size of the buffer used in bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2BufferSize(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info)">
            <summary>
            This function returns the size of the buffer used in bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2BufferSize(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info)">
            <summary>
            This function returns the size of the buffer used in bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Analysis(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Analysis(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Analysis(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Analysis(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Single@,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the solve phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Double@,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the solve phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the solve phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the solve phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the solve phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the solve phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the solve phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsv2Solve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsv2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the solve phase of bsrsv2, a new sparse triangular
            linear system op(A)*y = x.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtrA(mb) - bsrRowPtrA(0)) column indices of the nonzero blocks of matrix A. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="blockDim">block dimension of sparse matrix A; must be larger than zero.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemmi(System.Int32,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Description: dense - sparse matrix multiplication C = alpha * A * B  + beta * C, 
            where A is column-major dense matrix, B is a sparse matrix in CSC format, 
            and C is column-major dense matrix.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemmi(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Description: dense - sparse matrix multiplication C = alpha * A * B  + beta * C, 
            where A is column-major dense matrix, B is a sparse matrix in CSC format, 
            and C is column-major dense matrix.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemmi(System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Description: dense - sparse matrix multiplication C = alpha * A * B  + beta * C, 
            where A is column-major dense matrix, B is a sparse matrix in CSC format, 
            and C is column-major dense matrix.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemmi(System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Description: dense - sparse matrix multiplication C = alpha * A * B  + beta * C, 
            where A is column-major dense matrix, B is a sparse matrix in CSC format, 
            and C is column-major dense matrix.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemmi(System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Description: dense - sparse matrix multiplication C = alpha * A * B  + beta * C, 
            where A is column-major dense matrix, B is a sparse matrix in CSC format, 
            and C is column-major dense matrix.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemmi(System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Description: dense - sparse matrix multiplication C = alpha * A * B  + beta * C, 
            where A is column-major dense matrix, B is a sparse matrix in CSC format, 
            and C is column-major dense matrix.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemmi(System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Description: dense - sparse matrix multiplication C = alpha * A * B  + beta * C, 
            where A is column-major dense matrix, B is a sparse matrix in CSC format, 
            and C is column-major dense matrix.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gemmi(System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Description: dense - sparse matrix multiplication C = alpha * A * B  + beta * C, 
            where A is column-major dense matrix, B is a sparse matrix in CSC format, 
            and C is column-major dense matrix.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm2(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single@,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm2(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double@,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm2(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm2(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm2(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm2(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm2(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm2(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Xbsrsm2ZeroPivot(ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,System.Int32@)">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) is either a structural zero or a numerical zero (singular block). Otherwise
            position=-1. <para/>
            The position can be 0-base or 1-base, the same as the matrix.
            Function cusparseXbsrsm2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done.<para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains a structural zero or a
            numerical zero if the user already called bsrsm2_analysis() or bsrsm2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1;
            otherwise, if A(j,j) is missing or U(j,j) is zero,
            position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Xbsrsm2ZeroPivot(ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) is either a structural zero or a numerical zero (singular block). Otherwise
            position=-1. <para/>
            The position can be 0-base or 1-base, the same as the matrix.
            Function cusparseXbsrsm2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done.<para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains a structural zero or a
            numerical zero if the user already called bsrsm2_analysis() or bsrsm2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1;
            otherwise, if A(j,j) is missing or U(j,j) is zero,
            position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2BufferSize(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info)">
            <summary>
            This function returns size of buffer used in bsrsm2(), a new sparse triangular linear
            system op(A)*Y = alpha op(X).
            </summary>
            <param name="dirA">storage format of blocks, either 
            CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(X).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of matrix Y and op(X).</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL, while the supported diagonal types are CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrVal">array of nnzb bsrRowPtrA(mb) 
            bsrRowPtrA(0) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb +1 elements that contains the
            start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb (= bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A; larger than 
            zero.</param>
            <param name="info">record internal states based on different algorithms.</param>
            <returns>number of bytes of the buffer used in bsrsm2_analysis() and bsrsm2_solve().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2BufferSize(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info)">
            <summary>
            This function returns size of buffer used in bsrsm2(), a new sparse triangular linear
            system op(A)*Y = alpha op(X).
            </summary>
            <param name="dirA">storage format of blocks, either 
            CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(X).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of matrix Y and op(X).</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL, while the supported diagonal types are CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrVal">array of nnzb bsrRowPtrA(mb) 
            bsrRowPtrA(0) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb +1 elements that contains the
            start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb (= bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A; larger than 
            zero.</param>
            <param name="info">record internal states based on different algorithms.</param>
            <returns>number of bytes of the buffer used in bsrsm2_analysis() and bsrsm2_solve().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2BufferSize(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info)">
            <summary>
            This function returns size of buffer used in bsrsm2(), a new sparse triangular linear
            system op(A)*Y = alpha op(X).
            </summary>
            <param name="dirA">storage format of blocks, either 
            CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(X).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of matrix Y and op(X).</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL, while the supported diagonal types are CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrVal">array of nnzb bsrRowPtrA(mb) 
            bsrRowPtrA(0) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb +1 elements that contains the
            start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb (= bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A; larger than 
            zero.</param>
            <param name="info">record internal states based on different algorithms.</param>
            <returns>number of bytes of the buffer used in bsrsm2_analysis() and bsrsm2_solve().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2BufferSize(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info)">
            <summary>
            This function returns size of buffer used in bsrsm2(), a new sparse triangular linear
            system op(A)*Y = alpha op(X).
            </summary>
            <param name="dirA">storage format of blocks, either 
            CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(X).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of matrix Y and op(X).</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL, while the supported diagonal types are CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrVal">array of nnzb bsrRowPtrA(mb) 
            bsrRowPtrA(0) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb +1 elements that contains the
            start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb (= bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A; larger than 
            zero.</param>
            <param name="info">record internal states based on different algorithms.</param>
            <returns>number of bytes of the buffer used in bsrsm2_analysis() and bsrsm2_solve().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Analysis(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of bsrsm2(), a new sparse triangular linear
            system op(A)*op(Y) = alpha op(X).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(X).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of matrix Y and op(X).</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL, while the supported diagonal types are CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrVal">array of nnzb bsrRowPtrA(mb) 
            bsrRowPtrA(0) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb +1 elements that contains the
            start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb (= bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A; larger than 
            zero.</param>
            <param name="info">record internal states based on different algorithms.</param>
            <param name="policy">The supported policies are 
            CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is return by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Analysis(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of bsrsm2(), a new sparse triangular linear
            system op(A)*op(Y) = alpha op(X).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(X).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of matrix Y and op(X).</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL, while the supported diagonal types are CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrVal">array of nnzb bsrRowPtrA(mb) 
            bsrRowPtrA(0) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb +1 elements that contains the
            start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb (= bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A; larger than 
            zero.</param>
            <param name="info">record internal states based on different algorithms.</param>
            <param name="policy">The supported policies are 
            CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is return by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Analysis(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of bsrsm2(), a new sparse triangular linear
            system op(A)*op(Y) = alpha op(X).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(X).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of matrix Y and op(X).</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL, while the supported diagonal types are CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrVal">array of nnzb bsrRowPtrA(mb) 
            bsrRowPtrA(0) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb +1 elements that contains the
            start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb (= bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A; larger than 
            zero.</param>
            <param name="info">record internal states based on different algorithms.</param>
            <param name="policy">The supported policies are 
            CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is return by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Analysis(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of bsrsm2(), a new sparse triangular linear
            system op(A)*op(Y) = alpha op(X).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(X).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of matrix Y and op(X).</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL, while the supported diagonal types are CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrVal">array of nnzb bsrRowPtrA(mb) 
            bsrRowPtrA(0) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb +1 elements that contains the
            start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb (= bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A; larger than 
            zero.</param>
            <param name="info">record internal states based on different algorithms.</param>
            <param name="policy">The supported policies are 
            CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is return by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmm(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs one of the following matrix-matrix operations:
            C = alpha * op(A) * op(B) + beta * C
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrix op(B) and A.</param>
            <param name="kb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of non-zero blocks of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb + 1elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="B">array of dimensions (ldb, n) if op(B)=B and (ldb, k) otherwise.</param>
            <param name="ldb">leading dimension of B. If op(B)=B, it must be at least max(l,k) If op(B) != B, it must be at least
            max(1, n).</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max(l,m) if op(A)=A and at least max(l,k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmm(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs one of the following matrix-matrix operations:
            C = alpha * op(A) * op(B) + beta * C
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrix op(B) and A.</param>
            <param name="kb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of non-zero blocks of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb + 1elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="B">array of dimensions (ldb, n) if op(B)=B and (ldb, k) otherwise.</param>
            <param name="ldb">leading dimension of B. If op(B)=B, it must be at least max(l,k) If op(B) != B, it must be at least
            max(1, n).</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max(l,m) if op(A)=A and at least max(l,k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmm(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs one of the following matrix-matrix operations:
            C = alpha * op(A) * op(B) + beta * C
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrix op(B) and A.</param>
            <param name="kb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of non-zero blocks of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb + 1elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="B">array of dimensions (ldb, n) if op(B)=B and (ldb, k) otherwise.</param>
            <param name="ldb">leading dimension of B. If op(B)=B, it must be at least max(l,k) If op(B) != B, it must be at least
            max(1, n).</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max(l,m) if op(A)=A and at least max(l,k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmm(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs one of the following matrix-matrix operations:
            C = alpha * op(A) * op(B) + beta * C
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrix op(B) and A.</param>
            <param name="kb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of non-zero blocks of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb + 1elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="B">array of dimensions (ldb, n) if op(B)=B and (ldb, k) otherwise.</param>
            <param name="ldb">leading dimension of B. If op(B)=B, it must be at least max(l,k) If op(B) != B, it must be at least
            max(1, n).</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max(l,m) if op(A)=A and at least max(l,k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Solve(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the solution of a sparse triangular linear system:
            op(A) * op(Y) = alpha * op(X)
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(x) and op(Y).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of dense matrix Y and op(X).</param>
            <param name="nnzb">number of non-zero blocks of matrix A</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrVal">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="info">structure initialized using cusparseCreateBsrsm2Info().</param>
            <param name="X">right-hand-side array.</param>
            <param name="ldx">leading dimension of X. If op(X)=X, ldx&gt;=k; otherwise, ldx>=n.</param>
            <param name="Y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y. If op(A)=A, then ldc&gt;=m. If op(A)!=A, then ldx>=k.</param>
            <param name="policy">the supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Solve(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the solution of a sparse triangular linear system:
            op(A) * op(Y) = alpha * op(X)
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(x) and op(Y).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of dense matrix Y and op(X).</param>
            <param name="nnzb">number of non-zero blocks of matrix A</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrVal">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="info">structure initialized using cusparseCreateBsrsm2Info().</param>
            <param name="X">right-hand-side array.</param>
            <param name="ldx">leading dimension of X. If op(X)=X, ldx&gt;=k; otherwise, ldx>=n.</param>
            <param name="Y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y. If op(A)=A, then ldc&gt;=m. If op(A)!=A, then ldx>=k.</param>
            <param name="policy">the supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Solve(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the solution of a sparse triangular linear system:
            op(A) * op(Y) = alpha * op(X)
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(x) and op(Y).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of dense matrix Y and op(X).</param>
            <param name="nnzb">number of non-zero blocks of matrix A</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrVal">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="info">structure initialized using cusparseCreateBsrsm2Info().</param>
            <param name="X">right-hand-side array.</param>
            <param name="ldx">leading dimension of X. If op(X)=X, ldx&gt;=k; otherwise, ldx>=n.</param>
            <param name="Y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y. If op(A)=A, then ldc&gt;=m. If op(A)!=A, then ldx>=k.</param>
            <param name="policy">the supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Solve(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the solution of a sparse triangular linear system:
            op(A) * op(Y) = alpha * op(X)
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(x) and op(Y).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of dense matrix Y and op(X).</param>
            <param name="nnzb">number of non-zero blocks of matrix A</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrVal">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="info">structure initialized using cusparseCreateBsrsm2Info().</param>
            <param name="X">right-hand-side array.</param>
            <param name="ldx">leading dimension of X. If op(X)=X, ldx&gt;=k; otherwise, ldx>=n.</param>
            <param name="Y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y. If op(A)=A, then ldc&gt;=m. If op(A)!=A, then ldx>=k.</param>
            <param name="policy">the supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmm(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This function performs one of the following matrix-matrix operations:
            C = alpha * op(A) * op(B) + beta * C
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrix op(B) and A.</param>
            <param name="kb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of non-zero blocks of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb + 1elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="B">array of dimensions (ldb, n) if op(B)=B and (ldb, k) otherwise.</param>
            <param name="ldb">leading dimension of B. If op(B)=B, it must be at least max(l,k) If op(B) != B, it must be at least
            max(1, n).</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max(l,m) if op(A)=A and at least max(l,k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmm(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This function performs one of the following matrix-matrix operations:
            C = alpha * op(A) * op(B) + beta * C
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrix op(B) and A.</param>
            <param name="kb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of non-zero blocks of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb + 1elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="B">array of dimensions (ldb, n) if op(B)=B and (ldb, k) otherwise.</param>
            <param name="ldb">leading dimension of B. If op(B)=B, it must be at least max(l,k) If op(B) != B, it must be at least
            max(1, n).</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max(l,m) if op(A)=A and at least max(l,k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmm(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This function performs one of the following matrix-matrix operations:
            C = alpha * op(A) * op(B) + beta * C
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrix op(B) and A.</param>
            <param name="kb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of non-zero blocks of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb + 1elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="B">array of dimensions (ldb, n) if op(B)=B and (ldb, k) otherwise.</param>
            <param name="ldb">leading dimension of B. If op(B)=B, it must be at least max(l,k) If op(B) != B, it must be at least
            max(1, n).</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max(l,m) if op(A)=A and at least max(l,k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmm(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This function performs one of the following matrix-matrix operations:
            C = alpha * op(A) * op(B) + beta * C
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrix op(B) and A.</param>
            <param name="kb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of non-zero blocks of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb + 1elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="B">array of dimensions (ldb, n) if op(B)=B and (ldb, k) otherwise.</param>
            <param name="ldb">leading dimension of B. If op(B)=B, it must be at least max(l,k) If op(B) != B, it must be at least
            max(1, n).</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max(l,m) if op(A)=A and at least max(l,k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Solve(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the solution of a sparse triangular linear system:
            op(A) * op(Y) = alpha * op(X)
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(x) and op(Y).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of dense matrix Y and op(X).</param>
            <param name="nnzb">number of non-zero blocks of matrix A</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrVal">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="info">structure initialized using cusparseCreateBsrsm2Info().</param>
            <param name="X">right-hand-side array.</param>
            <param name="ldx">leading dimension of X. If op(X)=X, ldx&gt;=k; otherwise, ldx>=n.</param>
            <param name="Y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y. If op(A)=A, then ldc&gt;=m. If op(A)!=A, then ldx>=k.</param>
            <param name="policy">the supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Solve(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the solution of a sparse triangular linear system:
            op(A) * op(Y) = alpha * op(X)
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(x) and op(Y).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of dense matrix Y and op(X).</param>
            <param name="nnzb">number of non-zero blocks of matrix A</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrVal">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="info">structure initialized using cusparseCreateBsrsm2Info().</param>
            <param name="X">right-hand-side array.</param>
            <param name="ldx">leading dimension of X. If op(X)=X, ldx&gt;=k; otherwise, ldx>=n.</param>
            <param name="Y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y. If op(A)=A, then ldc&gt;=m. If op(A)!=A, then ldx>=k.</param>
            <param name="policy">the supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Solve(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the solution of a sparse triangular linear system:
            op(A) * op(Y) = alpha * op(X)
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(x) and op(Y).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of dense matrix Y and op(X).</param>
            <param name="nnzb">number of non-zero blocks of matrix A</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrVal">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="info">structure initialized using cusparseCreateBsrsm2Info().</param>
            <param name="X">right-hand-side array.</param>
            <param name="ldx">leading dimension of X. If op(X)=X, ldx&gt;=k; otherwise, ldx>=n.</param>
            <param name="Y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y. If op(A)=A, then ldc&gt;=m. If op(A)!=A, then ldx>=k.</param>
            <param name="policy">the supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrsm2Solve(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrsm2Info,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the solution of a sparse triangular linear system:
            op(A) * op(Y) = alpha * op(X)
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A).</param>
            <param name="transXY">the operation op(x) and op(Y).</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="n">number of columns of dense matrix Y and op(X).</param>
            <param name="nnzb">number of non-zero blocks of matrix A</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrVal">array of nnzb ( = bsrRowPtrA(mb) - 
            bsrRowPtrA(0) ) nonzero blocks of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb + 1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb ( =bsrRowPtrA(mb) -
            bsrRowPtrA(0) ) column indices of the nonzero blocks of matrix A.</param>
            <param name="blockSize">block dimension of sparse matrix A, larger than zero.</param>
            <param name="info">structure initialized using cusparseCreateBsrsm2Info().</param>
            <param name="X">right-hand-side array.</param>
            <param name="ldx">leading dimension of X. If op(X)=X, ldx&gt;=k; otherwise, ldx>=n.</param>
            <param name="Y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y. If op(A)=A, then ldc&gt;=m. If op(A)!=A, then ldx>=k.</param>
            <param name="policy">the supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by bsrsm2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-LU factorization with 0 fill-in and no pivoting <para/>
            op(A)  LU<para/>
            where A is m*n sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that the diagonal of lower triangular factor L is unitary and need not be stored.
            Therefore the input matrix is ovewritten with the resulting lower and upper triangular
            factor L and U, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-LU factorization with 0 fill-in and no pivoting <para/>
            op(A)  LU<para/>
            where A is m*n sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that the diagonal of lower triangular factor L is unitary and need not be stored.
            Therefore the input matrix is ovewritten with the resulting lower and upper triangular
            factor L and U, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-LU factorization with 0 fill-in and no pivoting <para/>
            op(A)  LU<para/>
            where A is m*n sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that the diagonal of lower triangular factor L is unitary and need not be stored.
            Therefore the input matrix is ovewritten with the resulting lower and upper triangular
            factor L and U, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-LU factorization with 0 fill-in and no pivoting <para/>
            op(A)  LU<para/>
            where A is m*n sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that the diagonal of lower triangular factor L is unitary and need not be stored.
            Therefore the input matrix is ovewritten with the resulting lower and upper triangular
            factor L and U, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02NumericBoost(ManagedCuda.CudaSparse.csrilu02Info,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            csrilu02(). To disable a boost value, the user can call csrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateCsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02NumericBoost(ManagedCuda.CudaSparse.csrilu02Info,System.Int32,System.Double@,System.Single@)">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            csrilu02(). To disable a boost value, the user can call csrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateCsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02NumericBoost(ManagedCuda.CudaSparse.csrilu02Info,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            csrilu02(). To disable a boost value, the user can call csrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateCsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02NumericBoost(ManagedCuda.CudaSparse.csrilu02Info,System.Int32,System.Double@,System.Double@)">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            csrilu02(). To disable a boost value, the user can call csrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateCsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02NumericBoost(ManagedCuda.CudaSparse.csrilu02Info,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            csrilu02(). To disable a boost value, the user can call csrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateCsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02NumericBoost(ManagedCuda.CudaSparse.csrilu02Info,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            csrilu02(). To disable a boost value, the user can call csrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateCsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02NumericBoost(ManagedCuda.CudaSparse.csrilu02Info,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            csrilu02(). To disable a boost value, the user can call csrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateCsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02NumericBoost(ManagedCuda.CudaSparse.csrilu02Info,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            csrilu02(). To disable a boost value, the user can call csrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateCsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02ZeroPivot(ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXcsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called csrsv2_analysis() or csrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02ZeroPivot(ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,System.Int32@)">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXcsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called csrsv2_analysis() or csrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02BufferSize(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info)">
            <summary>
            This function returns size of the buffer used in computing the incomplete-LU
            factorization with fill-in and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02BufferSize(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info)">
            <summary>
            This function returns size of the buffer used in computing the incomplete-LU
            factorization with fill-in and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02BufferSize(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info)">
            <summary>
            This function returns size of the buffer used in computing the incomplete-LU
            factorization with fill-in and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02BufferSize(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info)">
            <summary>
            This function returns size of the buffer used in computing the incomplete-LU
            factorization with fill-in and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02Analysis(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-LU factorization with fillin
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02Analysis(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-LU factorization with fillin
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02Analysis(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-LU factorization with fillin
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02Analysis(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-LU factorization with fillin
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-LU factorization with fill-in
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-LU factorization with fill-in
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-LU factorization with fill-in
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu02(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-LU factorization with fill-in
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02NumericBoost(ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            bsrilu02(). To disable a boost value, the user can call bsrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateBsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02NumericBoost(ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,System.Double@,System.Single@)">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            bsrilu02(). To disable a boost value, the user can call bsrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateBsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02NumericBoost(ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            bsrilu02(). To disable a boost value, the user can call bsrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateBsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02NumericBoost(ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,System.Double@,System.Double@)">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            bsrilu02(). To disable a boost value, the user can call bsrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateBsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02NumericBoost(ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            bsrilu02(). To disable a boost value, the user can call bsrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateBsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02NumericBoost(ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            bsrilu02(). To disable a boost value, the user can call bsrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateBsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02NumericBoost(ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            bsrilu02(). To disable a boost value, the user can call bsrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateBsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02NumericBoost(ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary>
            The user can use a boost value to replace a numerical value in incomplete LU
            factorization. The tol is used to determine a numerical zero, and the boost_val is used
            to replace a numerical zero. The behavior is <para/>
            if tol >= fabs(A(j,j)), then A(j,j)=boost_val.<para/>
            To enable a boost value, the user has to set parameter enable_boost to 1 before calling
            bsrilu02(). To disable a boost value, the user can call bsrilu02_numericBoost()
            again with parameter enable_boost=0.<para/>
            If enable_boost=0, tol and boost_val are ignored.
            </summary>
            <param name="info">structure initialized using cusparseCreateBsrilu02Info().</param>
            <param name="enable_boost">disable boost by enable_boost=0; otherwise, boost is enabled.</param>
            <param name="tol">tolerance to determine a numerical zero.</param>
            <param name="boost_val">boost value to replace a numerical zero.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02ZeroPivot(ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXbsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called bsrsv2_analysis() or bsrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02ZeroPivot(ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,System.Int32@)">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXbsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called bsrsv2_analysis() or bsrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02BufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info)">
            <summary>
            This function returns size of the buffer used in computing the incomplete-LU
            factorization with fill-in and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02BufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info)">
            <summary>
            This function returns size of the buffer used in computing the incomplete-LU
            factorization with fill-in and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02BufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info)">
            <summary>
            This function returns size of the buffer used in computing the incomplete-LU
            factorization with fill-in and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02BufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info)">
            <summary>
            This function returns size of the buffer used in computing the incomplete-LU
            factorization with fill-in and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02Analysis(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-LU factorization with 0 fillin
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02Analysis(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-LU factorization with fillin
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02Analysis(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-LU factorization with fillin
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02Analysis(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-LU factorization with fillin
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-LU factorization with fill-in
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA_ValM">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-LU factorization with fill-in
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA_ValM">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-LU factorization with fill-in
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA_ValM">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrilu02(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-LU factorization with fill-in
            and no pivoting: A = LU
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA_ValM">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-Cholesky factorization with 0 fill-in and no pivoting <para/>
            op(A)  R'R<para/>
            where A is m*n Hermitian/symmetric positive definite sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that only a lower or upper Hermitian/symmetric part of the matrix A is actually
            stored. It is overwritten by the lower or upper triangular factor R' or R, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-Cholesky factorization with 0 fill-in and no pivoting <para/>
            op(A)  R'R<para/>
            where A is m*n Hermitian/symmetric positive definite sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that only a lower or upper Hermitian/symmetric part of the matrix A is actually
            stored. It is overwritten by the lower or upper triangular factor R' or R, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-Cholesky factorization with 0 fill-in and no pivoting <para/>
            op(A)  R'R<para/>
            where A is m*n Hermitian/symmetric positive definite sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that only a lower or upper Hermitian/symmetric part of the matrix A is actually
            stored. It is overwritten by the lower or upper triangular factor R' or R, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-Cholesky factorization with 0 fill-in and no pivoting <para/>
            op(A)  R'R<para/>
            where A is m*n Hermitian/symmetric positive definite sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that only a lower or upper Hermitian/symmetric part of the matrix A is actually
            stored. It is overwritten by the lower or upper triangular factor R' or R, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02ZeroPivot(ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXcsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called csrsv2_analysis() or csrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02ZeroPivot(ManagedCuda.CudaSparse.CudaSparseCsric02Info,System.Int32@)">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXcsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called csrsv2_analysis() or csrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02BufferSize(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info)">
            <summary>
            This function returns size of buffer used in computing the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02BufferSize(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info)">
            <summary>
            This function returns size of buffer used in computing the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02BufferSize(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info)">
            <summary>
            This function returns size of buffer used in computing the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02BufferSize(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info)">
            <summary>
            This function returns size of buffer used in computing the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02Analysis(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02Analysis(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02Analysis(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02Analysis(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric02(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by csrsv2_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02ZeroPivot(ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXbsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called bsrsv2_analysis() or bsrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02ZeroPivot(ManagedCuda.CudaSparse.CudaSparseBsric02Info,System.Int32@)">
            <summary>
            If the returned error code is CUSPARSE_STATUS_ZERO_PIVOT, position=j means
            A(j,j) has either a structural zero or a numerical zero. Otherwise position=-1. <para/>
            The position can be 0-based or 1-based, the same as the matrix. <para/>
            Function cusparseXbsrsv2_zeroPivot() is a blocking call. It calls
            cudaDeviceSynchronize() to make sure all previous kernels are done. <para/>
            The position can be in the host memory or device memory. The user can set the proper
            mode with cusparseSetPointerMode().
            </summary>
            <param name="info">info contains structural zero or numerical zero if the user already called bsrsv2_analysis() or bsrsv2_solve().</param>
            <param name="position">if no structural or numerical zero, position is -1; otherwise, if A(j,j) is missing or U(j,j) is zero, position=j.</param>
            <returns>If true, position=j means A(j,j) has either a structural zero or a numerical zero; otherwise, position=-1.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02BufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info)">
            <summary>
            This function returns size of buffer used in computing the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02BufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info)">
            <summary>
            This function returns size of buffer used in computing the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02BufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info)">
            <summary>
            This function returns size of buffer used in computing the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02BufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info)">
            <summary>
            This function returns size of buffer used in computing the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02Analysis(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02Analysis(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02Analysis(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02Analysis(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the analysis phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA_ValM">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA_ValM">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA_ValM">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsric02(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseBsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs the solve phase of the incomplete-Cholesky
            factorization with fill-in and no pivoting: A = LL^H
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="bsrValA_ValM">array of nnz (= bsrRowPtrA(m)-bsrRowPtrA(0)) non-zero elements of matrix A. <para/>Output: matrix containing the incomplete-LU lower and upper triangular factors.</param>
            <param name="bsrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="bsrColIndA">integer array of nnz (= bsrRowPtrA(m) - bsrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of bsrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">record of internal states based on different algorithms.</param>
            <param name="policy">The supported policies are CUSPARSE_SOLVE_POLICY_NO_LEVEL and CUSPARSE_SOLVE_POLICY_USE_LEVEL.</param>
            <param name="buffer">buffer allocated by the user, the size is returned by bsrsv2_bufferSizeExt().</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Solution of tridiagonal linear system A * B = B, with multiple right-hand-sides. The coefficient matrix A is 
            composed of lower (dl), main (d) and upper (du) diagonals, and the right-hand-sides B are overwritten with the solution.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="n">number of right-hand-sides, columns of matrix B.</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal
            linear system. The first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.</param>
            <param name="B">dense right-hand-side array of dimensions (ldb, m).</param>
            <param name="ldb">leading dimension of B (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Solution of tridiagonal linear system A * B = B, with multiple right-hand-sides. The coefficient matrix A is 
            composed of lower (dl), main (d) and upper (du) diagonals, and the right-hand-sides B are overwritten with the solution.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="n">number of right-hand-sides, columns of matrix B.</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal
            linear system. The first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.</param>
            <param name="B">dense right-hand-side array of dimensions (ldb, m).</param>
            <param name="ldb">leading dimension of B (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Solution of tridiagonal linear system A * B = B, with multiple right-hand-sides. The coefficient matrix A is 
            composed of lower (dl), main (d) and upper (du) diagonals, and the right-hand-sides B are overwritten with the solution.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="n">number of right-hand-sides, columns of matrix B.</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal
            linear system. The first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.</param>
            <param name="B">dense right-hand-side array of dimensions (ldb, m).</param>
            <param name="ldb">leading dimension of B (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Solution of tridiagonal linear system A * B = B, with multiple right-hand-sides. The coefficient matrix A is 
            composed of lower (dl), main (d) and upper (du) diagonals, and the right-hand-sides B are overwritten with the solution.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="n">number of right-hand-sides, columns of matrix B.</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal
            linear system. The first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.</param>
            <param name="B">dense right-hand-side array of dimensions (ldb, m).</param>
            <param name="ldb">leading dimension of B (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv_nopivot(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv_nopivot(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv_nopivot(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv_nopivot(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GtsvStridedBatch(System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int32)">
            <summary>
            Solution of a set of tridiagonal linear systems A * x = x, each with a single right-hand-side. The coefficient 
            matrices A are composed of lower (dl), main (d) and upper (du) diagonals and stored separated by a batchStride, while the 
            right-hand-sides x are also separated by a batchStride.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal 
            linear system. The lower diagonal dl(i) that corresponds to the ith linear system starts at location dl + batchStride * i in memory.
            Also, the first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal d(i) that corresponds to the ith
            linear system starts at location d + batchStride * i in memory.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal du(i) that corresponds to the ith
            linear system starts at location du + batchStride * i in memory. Also, the last element of each upper diagonal must be zero.</param>
            <param name="x">dense array that contains the right-hand-side of the tridiagonal linear system. The right-hand-side x(i) that corresponds 
            to the ith linear system starts at location x + batchStride * i in memory.</param>
            <param name="batchCount">Number of systems to solve.</param>
            <param name="batchStride">stride (number of elements) that separates the vectors of every system (must be at least m).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GtsvStridedBatch(System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int32)">
            <summary>
            Solution of a set of tridiagonal linear systems A * x = x, each with a single right-hand-side. The coefficient 
            matrices A are composed of lower (dl), main (d) and upper (du) diagonals and stored separated by a batchStride, while the 
            right-hand-sides x are also separated by a batchStride.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal 
            linear system. The lower diagonal dl(i) that corresponds to the ith linear system starts at location dl + batchStride * i in memory.
            Also, the first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal d(i) that corresponds to the ith
            linear system starts at location d + batchStride * i in memory.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal du(i) that corresponds to the ith
            linear system starts at location du + batchStride * i in memory. Also, the last element of each upper diagonal must be zero.</param>
            <param name="x">dense array that contains the right-hand-side of the tridiagonal linear system. The right-hand-side x(i) that corresponds 
            to the ith linear system starts at location x + batchStride * i in memory.</param>
            <param name="batchCount">Number of systems to solve.</param>
            <param name="batchStride">stride (number of elements) that separates the vectors of every system (must be at least m).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GtsvStridedBatch(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int32)">
            <summary>
            Solution of a set of tridiagonal linear systems A * x = x, each with a single right-hand-side. The coefficient 
            matrices A are composed of lower (dl), main (d) and upper (du) diagonals and stored separated by a batchStride, while the 
            right-hand-sides x are also separated by a batchStride.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal 
            linear system. The lower diagonal dl(i) that corresponds to the ith linear system starts at location dl + batchStride * i in memory.
            Also, the first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal d(i) that corresponds to the ith
            linear system starts at location d + batchStride * i in memory.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal du(i) that corresponds to the ith
            linear system starts at location du + batchStride * i in memory. Also, the last element of each upper diagonal must be zero.</param>
            <param name="x">dense array that contains the right-hand-side of the tridiagonal linear system. The right-hand-side x(i) that corresponds 
            to the ith linear system starts at location x + batchStride * i in memory.</param>
            <param name="batchCount">Number of systems to solve.</param>
            <param name="batchStride">stride (number of elements) that separates the vectors of every system (must be at least m).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GtsvStridedBatch(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int32)">
            <summary>
            Solution of a set of tridiagonal linear systems A * x = x, each with a single right-hand-side. The coefficient 
            matrices A are composed of lower (dl), main (d) and upper (du) diagonals and stored separated by a batchStride, while the 
            right-hand-sides x are also separated by a batchStride.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal 
            linear system. The lower diagonal dl(i) that corresponds to the ith linear system starts at location dl + batchStride * i in memory.
            Also, the first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal d(i) that corresponds to the ith
            linear system starts at location d + batchStride * i in memory.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal du(i) that corresponds to the ith
            linear system starts at location du + batchStride * i in memory. Also, the last element of each upper diagonal must be zero.</param>
            <param name="x">dense array that contains the right-hand-side of the tridiagonal linear system. The right-hand-side x(i) that corresponds 
            to the ith linear system starts at location x + batchStride * i in memory.</param>
            <param name="batchCount">Number of systems to solve.</param>
            <param name="batchStride">stride (number of elements) that separates the vectors of every system (must be at least m).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz_compress(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single)">
            <summary>
            This routine finds the total number of non-zero elements and 
            the number of non-zero elements per row in a noncompressed csr matrix A.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz_compress(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double)">
            <summary>
            This routine finds the total number of non-zero elements and 
            the number of non-zero elements per row in a noncompressed csr matrix A.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz_compress(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex)">
            <summary>
            This routine finds the total number of non-zero elements and 
            the number of non-zero elements per row in a noncompressed csr matrix A.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz_compress(System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex)">
            <summary>
            This routine finds the total number of non-zero elements and 
            the number of non-zero elements per row in a noncompressed csr matrix A.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csr_compress(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single)">
            <summary>
            This routine takes as input a csr form where the values may have 0 elements
            and compresses it to return a csr form with no zeros.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csr_compress(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double)">
            <summary>
            This routine takes as input a csr form where the values may have 0 elements
            and compresses it to return a csr form with no zeros.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csr_compress(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex)">
            <summary>
            This routine takes as input a csr form where the values may have 0 elements
            and compresses it to return a csr form with no zeros.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csr_compress(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex)">
            <summary>
            This routine takes as input a csr form where the values may have 0 elements
            and compresses it to return a csr form with no zeros.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSR storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="csrValA">Output: array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">Output: integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSR storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="csrValA">Output: array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">Output: integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSR storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="csrValA">Output: array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">Output: integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSR storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="csrValA">Output: array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">Output: integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of array matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of array matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of array matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of array matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csc(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSC storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerCol">array of size n containing the number of non-zero elements per column.</param>
            <param name="cscValA">Output: array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csc(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSC storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerCol">array of size n containing the number of non-zero elements per column.</param>
            <param name="cscValA">Output: array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csc(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSC storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerCol">array of size n containing the number of non-zero elements per column.</param>
            <param name="cscValA">Output: array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csc(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSC storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerCol">array of size n containing the number of non-zero elements per column.</param>
            <param name="cscValA">Output: array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSC storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="cscValA">array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of dense array A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSC storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="cscValA">array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of dense array A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSC storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="cscValA">array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of dense array A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSC storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="cscValA">array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of dense array A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Xcoo2csr(ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine compresses the indecis of rows or columns. It can be interpreted as a conversion from COO to CSR sparse storage format.
            </summary>
            <param name="cooRowInd">integer array of nnz uncompressed row indices. Length of cooRowInd gives the number nzz passed to CUSPARSE.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="csrRowPtr">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Xcsr2coo(ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine uncompresses the indecis of rows or columns. It can be interpreted as a conversion from CSR to COO sparse storage format.
            </summary>
            <param name="csrRowPtr">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="cooRowInd">integer array of nnz uncompressed row indices. Length of cooRowInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csc(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine converts a matrix from CSR to CSC sparse storage format. The resulting matrix can be re-interpreted as a transpose of the original matrix in CSR storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. Length of csrColInd gives the number nzz passed to CUSPARSE.</param>
            <param name="cscVal">Output: array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) nonzero elements of matrix A. It is only filled-in if copyValues is set
            to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="cscRowInd">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtr">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csc(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine converts a matrix from CSR to CSC sparse storage format. The resulting matrix can be re-interpreted as a transpose of the original matrix in CSR storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. Length of csrColInd gives the number nzz passed to CUSPARSE.</param>
            <param name="cscVal">Output: array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) nonzero elements of matrix A. It is only filled-in if copyValues is set
            to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="cscRowInd">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtr">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csc(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine converts a matrix from CSR to CSC sparse storage format. The resulting matrix can be re-interpreted as a transpose of the original matrix in CSR storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. Length of csrColInd gives the number nzz passed to CUSPARSE.</param>
            <param name="cscVal">Output: array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) nonzero elements of matrix A. It is only filled-in if copyValues is set
            to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="cscRowInd">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtr">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csc(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine converts a matrix from CSR to CSC sparse storage format. The resulting matrix can be re-interpreted as a transpose of the original matrix in CSR storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. Length of csrColInd gives the number nzz passed to CUSPARSE.</param>
            <param name="cscVal">Output: array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) nonzero elements of matrix A. It is only filled-in if copyValues is set
            to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="cscRowInd">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtr">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a dense matrix to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of the dense matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="hybA">Output: the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which
            should be less than maximum number of non-zeros per row and is only required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a dense matrix to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of the dense matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="hybA">Output: the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which
            should be less than maximum number of non-zeros per row and is only required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a dense matrix to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of the dense matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="hybA">Output: the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which
            should be less than maximum number of non-zeros per row and is only required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a dense matrix to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of the dense matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="hybA">Output: the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which
            should be less than maximum number of non-zeros per row and is only required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2dense(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This routine converts a sparse matrix in HYB storage format to a dense matrix.
            </summary>
            <param name="descrA">the descriptor of the matrix A in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="A">array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">the matrix A in HYB storage format.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2dense(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This routine converts a sparse matrix in HYB storage format to a dense matrix.
            </summary>
            <param name="descrA">the descriptor of the matrix A in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="A">array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">the matrix A in HYB storage format.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2dense(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in HYB storage format to a dense matrix.
            </summary>
            <param name="descrA">the descriptor of the matrix A in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="A">array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">the matrix A in HYB storage format.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2dense(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in HYB storage format to a dense matrix.
            </summary>
            <param name="descrA">the descriptor of the matrix A in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="A">array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">the matrix A in HYB storage format.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A in CSR format. The supported matrix type 
            is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which should be less than maximum number of non-zeros per row and is only
            required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A in CSR format. The supported matrix type 
            is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which should be less than maximum number of non-zeros per row and is only
            required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A in CSR format. The supported matrix type 
            is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which should be less than maximum number of non-zeros per row and is only
            required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A in CSR format. The supported matrix type 
            is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which should be less than maximum number of non-zeros per row and is only
            required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrgemmNnz(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrgemmNnz(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2BufferSize(System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info)">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <returns>number of bytes of the buffer used in csrgemm2Nnnz and csrgemm2.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2BufferSize(System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info)">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <returns>number of bytes of the buffer used in csrgemm2Nnnz and csrgemm2.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2BufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info)">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <returns>number of bytes of the buffer used in csrgemm2Nnnz and csrgemm2.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2BufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info)">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <returns>number of bytes of the buffer used in csrgemm2Nnnz and csrgemm2.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2BufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info)">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <returns>number of bytes of the buffer used in csrgemm2Nnnz and csrgemm2.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2BufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info)">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <returns>number of bytes of the buffer used in csrgemm2Nnnz and csrgemm2.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2BufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info)">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <returns>number of bytes of the buffer used in csrgemm2Nnnz and csrgemm2.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2BufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info)">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <returns>number of bytes of the buffer used in csrgemm2Nnnz and csrgemm2.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2(System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedValA">array of nnzA nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedValB">array of nnzB nonzero elements of matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedValD">array of nnzD nonzero elements of matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedValC">array of nnzC nonzero elements of matrix C.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndC">integer array of nnzC column indices of the nonzero elements of matrix C.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2(System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedValA">array of nnzA nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedValB">array of nnzB nonzero elements of matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedValD">array of nnzD nonzero elements of matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedValC">array of nnzC nonzero elements of matrix C.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndC">integer array of nnzC column indices of the nonzero elements of matrix C.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2(System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedValA">array of nnzA nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedValB">array of nnzB nonzero elements of matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedValD">array of nnzD nonzero elements of matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedValC">array of nnzC nonzero elements of matrix C.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndC">integer array of nnzC column indices of the nonzero elements of matrix C.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2(System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedValA">array of nnzA nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedValB">array of nnzB nonzero elements of matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedValD">array of nnzD nonzero elements of matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedValC">array of nnzC nonzero elements of matrix C.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndC">integer array of nnzC column indices of the nonzero elements of matrix C.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedValA">array of nnzA nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedValB">array of nnzB nonzero elements of matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedValD">array of nnzD nonzero elements of matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedValC">array of nnzC nonzero elements of matrix C.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndC">integer array of nnzC column indices of the nonzero elements of matrix C.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedValA">array of nnzA nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedValB">array of nnzB nonzero elements of matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedValD">array of nnzD nonzero elements of matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedValC">array of nnzC nonzero elements of matrix C.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndC">integer array of nnzC column indices of the nonzero elements of matrix C.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedValA">array of nnzA nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedValB">array of nnzB nonzero elements of matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedValD">array of nnzD nonzero elements of matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedValC">array of nnzC nonzero elements of matrix C.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndC">integer array of nnzC column indices of the nonzero elements of matrix C.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedValA">array of nnzA nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedValB">array of nnzB nonzero elements of matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedValD">array of nnzD nonzero elements of matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedValC">array of nnzC nonzero elements of matrix C.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndC">integer array of nnzC column indices of the nonzero elements of matrix C.</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2Nnz(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr">total number of nonzero elements in device or host memory. It is equal to (csrRowPtrC(m)-csrRowPtrC(0)).</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm2Nnz(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@,ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function performs following matrix-matrix operation:<para/>
            C = alpha * A *A B + beta * D<para/>
            where A, B, D and C are mk, kn, mn and mn sparse matrices (defined in CSR storage
            format by the three arrays csrValA|csrValB|csrValD|csrValC, csrRowPtrA|
            csrRowPtrB|csrRowPtrD|csrRowPtrC, and csrColIndA|csrColIndB|csrColIndD|csrcolIndC respectively.
            </summary>
            <param name="m">number of rows of sparse matrix A, D and C.</param>
            <param name="n">number of columns of sparse matrix B, D and C.</param>
            <param name="k">number of columns/rows of sparse matrix A / B.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzA">number of nonzero elements of sparse matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnzA column indices of the nonzero elements of matrix A.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only</param>
            <param name="nnzB">number of nonzero elements of sparse matrix B.</param>
            <param name="csrSortedRowPtrB">integer array of k+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndB">integer array of nnzB column indices of the nonzero elements of matrix B.</param>
            <param name="descrD">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="nnzD">number of nonzero elements of sparse matrix D.</param>
            <param name="csrSortedRowPtrD">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndD">integer array of nnzD column indices of the nonzero elements of matrix D.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrSortedRowPtrC">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr">total number of nonzero elements in device or host memory. It is equal to (csrRowPtrC(m)-csrRowPtrC(0)).</param>
            <param name="info">structure with information used in csrgemm2Nnz and csrgemm2.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by csrgemm2BufferSize</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrgeamNnz(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrgeamNnz(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrcolor(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,System.Int32@,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseColorInfo)">
            <summary>
            This function performs the coloring of the adjacency graph associated with the matrix
            A stored in CSR format. The coloring is an assignment of colors (integer numbers)
            to nodes, such that neighboring nodes have distinct colors. An approximate coloring
            algorithm is used in this routine, and is stopped when a certain percentage of nodes has
            been colored. The rest of the nodes are assigned distinct colors (an increasing sequence
            of integers numbers, starting from the last integer used previously). The last two
            auxiliary routines can be used to extract the resulting number of colors, their assignment
            and the associated reordering. The reordering is such that nodes that have been assigned
            the same color are reordered to be next to each other.<para/>
            The matrix A passed to this routine, must be stored as a general matrix and have a
            symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T
            as a parameter to this routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are 
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrSortedValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix A.</param>
            <param name="fractionToColor">fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.</param>
            <param name="ncolors">The number of distinct colors used (at most the size of the matrix, but likely much smaller).</param>
            <param name="coloring">The resulting coloring permutation.</param>
            <param name="reordering">The resulting reordering permutation (untouched if NULL)</param>
            <param name="info">structure with information to be passed to the coloring.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrcolor(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,System.Int32@,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseColorInfo)">
            <summary>
            This function performs the coloring of the adjacency graph associated with the matrix
            A stored in CSR format. The coloring is an assignment of colors (integer numbers)
            to nodes, such that neighboring nodes have distinct colors. An approximate coloring
            algorithm is used in this routine, and is stopped when a certain percentage of nodes has
            been colored. The rest of the nodes are assigned distinct colors (an increasing sequence
            of integers numbers, starting from the last integer used previously). The last two
            auxiliary routines can be used to extract the resulting number of colors, their assignment
            and the associated reordering. The reordering is such that nodes that have been assigned
            the same color are reordered to be next to each other.<para/>
            The matrix A passed to this routine, must be stored as a general matrix and have a
            symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T
            as a parameter to this routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are 
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrSortedValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix A.</param>
            <param name="fractionToColor">fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.</param>
            <param name="ncolors">The number of distinct colors used (at most the size of the matrix, but likely much smaller).</param>
            <param name="coloring">The resulting coloring permutation.</param>
            <param name="reordering">The resulting reordering permutation (untouched if NULL)</param>
            <param name="info">structure with information to be passed to the coloring.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrcolor(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,System.Int32@,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseColorInfo)">
            <summary>
            This function performs the coloring of the adjacency graph associated with the matrix
            A stored in CSR format. The coloring is an assignment of colors (integer numbers)
            to nodes, such that neighboring nodes have distinct colors. An approximate coloring
            algorithm is used in this routine, and is stopped when a certain percentage of nodes has
            been colored. The rest of the nodes are assigned distinct colors (an increasing sequence
            of integers numbers, starting from the last integer used previously). The last two
            auxiliary routines can be used to extract the resulting number of colors, their assignment
            and the associated reordering. The reordering is such that nodes that have been assigned
            the same color are reordered to be next to each other.<para/>
            The matrix A passed to this routine, must be stored as a general matrix and have a
            symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T
            as a parameter to this routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are 
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrSortedValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix A.</param>
            <param name="fractionToColor">fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.</param>
            <param name="ncolors">The number of distinct colors used (at most the size of the matrix, but likely much smaller).</param>
            <param name="coloring">The resulting coloring permutation.</param>
            <param name="reordering">The resulting reordering permutation (untouched if NULL)</param>
            <param name="info">structure with information to be passed to the coloring.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrcolor(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,System.Int32@,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseColorInfo)">
            <summary>
            This function performs the coloring of the adjacency graph associated with the matrix
            A stored in CSR format. The coloring is an assignment of colors (integer numbers)
            to nodes, such that neighboring nodes have distinct colors. An approximate coloring
            algorithm is used in this routine, and is stopped when a certain percentage of nodes has
            been colored. The rest of the nodes are assigned distinct colors (an increasing sequence
            of integers numbers, starting from the last integer used previously). The last two
            auxiliary routines can be used to extract the resulting number of colors, their assignment
            and the associated reordering. The reordering is such that nodes that have been assigned
            the same color are reordered to be next to each other.<para/>
            The matrix A passed to this routine, must be stored as a general matrix and have a
            symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T
            as a parameter to this routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are 
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrSortedValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix A.</param>
            <param name="fractionToColor">fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.</param>
            <param name="ncolors">The number of distinct colors used (at most the size of the matrix, but likely much smaller).</param>
            <param name="coloring">The resulting coloring permutation.</param>
            <param name="reordering">The resulting reordering permutation (untouched if NULL)</param>
            <param name="info">structure with information to be passed to the coloring.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrcolor(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseColorInfo)">
            <summary>
            This function performs the coloring of the adjacency graph associated with the matrix
            A stored in CSR format. The coloring is an assignment of colors (integer numbers)
            to nodes, such that neighboring nodes have distinct colors. An approximate coloring
            algorithm is used in this routine, and is stopped when a certain percentage of nodes has
            been colored. The rest of the nodes are assigned distinct colors (an increasing sequence
            of integers numbers, starting from the last integer used previously). The last two
            auxiliary routines can be used to extract the resulting number of colors, their assignment
            and the associated reordering. The reordering is such that nodes that have been assigned
            the same color are reordered to be next to each other.<para/>
            The matrix A passed to this routine, must be stored as a general matrix and have a
            symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T
            as a parameter to this routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are 
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrSortedValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix A.</param>
            <param name="fractionToColor">fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.</param>
            <param name="ncolors">The number of distinct colors used (at most the size of the matrix, but likely much smaller).</param>
            <param name="coloring">The resulting coloring permutation.</param>
            <param name="reordering">The resulting reordering permutation (untouched if NULL)</param>
            <param name="info">structure with information to be passed to the coloring.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrcolor(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseColorInfo)">
            <summary>
            This function performs the coloring of the adjacency graph associated with the matrix
            A stored in CSR format. The coloring is an assignment of colors (integer numbers)
            to nodes, such that neighboring nodes have distinct colors. An approximate coloring
            algorithm is used in this routine, and is stopped when a certain percentage of nodes has
            been colored. The rest of the nodes are assigned distinct colors (an increasing sequence
            of integers numbers, starting from the last integer used previously). The last two
            auxiliary routines can be used to extract the resulting number of colors, their assignment
            and the associated reordering. The reordering is such that nodes that have been assigned
            the same color are reordered to be next to each other.<para/>
            The matrix A passed to this routine, must be stored as a general matrix and have a
            symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T
            as a parameter to this routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are 
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrSortedValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix A.</param>
            <param name="fractionToColor">fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.</param>
            <param name="ncolors">The number of distinct colors used (at most the size of the matrix, but likely much smaller).</param>
            <param name="coloring">The resulting coloring permutation.</param>
            <param name="reordering">The resulting reordering permutation (untouched if NULL)</param>
            <param name="info">structure with information to be passed to the coloring.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrcolor(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseColorInfo)">
            <summary>
            This function performs the coloring of the adjacency graph associated with the matrix
            A stored in CSR format. The coloring is an assignment of colors (integer numbers)
            to nodes, such that neighboring nodes have distinct colors. An approximate coloring
            algorithm is used in this routine, and is stopped when a certain percentage of nodes has
            been colored. The rest of the nodes are assigned distinct colors (an increasing sequence
            of integers numbers, starting from the last integer used previously). The last two
            auxiliary routines can be used to extract the resulting number of colors, their assignment
            and the associated reordering. The reordering is such that nodes that have been assigned
            the same color are reordered to be next to each other.<para/>
            The matrix A passed to this routine, must be stored as a general matrix and have a
            symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T
            as a parameter to this routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are 
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrSortedValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix A.</param>
            <param name="fractionToColor">fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.</param>
            <param name="ncolors">The number of distinct colors used (at most the size of the matrix, but likely much smaller).</param>
            <param name="coloring">The resulting coloring permutation.</param>
            <param name="reordering">The resulting reordering permutation (untouched if NULL)</param>
            <param name="info">structure with information to be passed to the coloring.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrcolor(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseColorInfo)">
            <summary>
            This function performs the coloring of the adjacency graph associated with the matrix
            A stored in CSR format. The coloring is an assignment of colors (integer numbers)
            to nodes, such that neighboring nodes have distinct colors. An approximate coloring
            algorithm is used in this routine, and is stopped when a certain percentage of nodes has
            been colored. The rest of the nodes are assigned distinct colors (an increasing sequence
            of integers numbers, starting from the last integer used previously). The last two
            auxiliary routines can be used to extract the resulting number of colors, their assignment
            and the associated reordering. The reordering is such that nodes that have been assigned
            the same color are reordered to be next to each other.<para/>
            The matrix A passed to this routine, must be stored as a general matrix and have a
            symmetric sparsity pattern. If the matrix is nonsymmetric the user should pass A+A^T
            as a parameter to this routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are 
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrSortedValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) nonzero elements of matrix A.</param>
            <param name="csrSortedRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrSortedColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix A.</param>
            <param name="fractionToColor">fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.</param>
            <param name="ncolors">The number of distinct colors used (at most the size of the matrix, but likely much smaller).</param>
            <param name="coloring">The resulting coloring permutation.</param>
            <param name="reordering">The resulting reordering permutation (untouched if NULL)</param>
            <param name="info">structure with information to be passed to the coloring.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csr(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in HYB format into a sparse matrix in CSR format.<para/>
            This function requires some amount of temporary storage. It is executed asynchronously
            with respect to the host and it may return control to the application on the host before
            the result is ready.
            </summary>
            <param name="descrA">the descriptor of matrix in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format</param>
            <param name="csrValA">array of nnz csrRowPtrA(m) csrRowPtrA(0) non-zero elements of matrix A</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every column and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix .</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csr(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in HYB format into a sparse matrix in CSR format.<para/>
            This function requires some amount of temporary storage. It is executed asynchronously
            with respect to the host and it may return control to the application on the host before
            the result is ready.
            </summary>
            <param name="descrA">the descriptor of matrix in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format</param>
            <param name="csrValA">array of nnz csrRowPtrA(m) csrRowPtrA(0) non-zero elements of matrix A</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every column and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix .</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csr(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in HYB format into a sparse matrix in CSR format.<para/>
            This function requires some amount of temporary storage. It is executed asynchronously
            with respect to the host and it may return control to the application on the host before
            the result is ready.
            </summary>
            <param name="descrA">the descriptor of matrix in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format</param>
            <param name="csrValA">array of nnz csrRowPtrA(m) csrRowPtrA(0) non-zero elements of matrix A</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every column and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix .</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csr(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in HYB format into a sparse matrix in CSR format.<para/>
            This function requires some amount of temporary storage. It is executed asynchronously
            with respect to the host and it may return control to the application on the host before
            the result is ready.
            </summary>
            <param name="descrA">the descriptor of matrix in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format</param>
            <param name="csrValA">array of nnz csrRowPtrA(m) csrRowPtrA(0) non-zero elements of matrix A</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every column and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix .</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csc(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csc(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csc(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csc(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsrNnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsrNnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero 
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrValC">array of nnzb*blockDim non-zero elements of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndC">integer array of nnzb column indices of the non-zero blocks of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero 
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrValC">array of nnzb*blockDim non-zero elements of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndC">integer array of nnzb column indices of the non-zero blocks of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero 
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrValC">array of nnzb*blockDim non-zero elements of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndC">integer array of nnzb column indices of the non-zero blocks of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero 
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrValC">array of nnzb*blockDim non-zero elements of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndC">integer array of nnzb column indices of the non-zero blocks of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in BSR format (that is defined by the three arrays
            bsrValA, bsrRowPtrA and bsrColIndA) into a sparse matrix in CSR format (that is
            defined by arrays csrValC, csrRowPtrC, and csrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A. The number of rows of sparse matrix C is m(= mb*blockDim).</param>
            <param name="nb">number of block columns of sparse matrix A. The number of columns of sparse matrix C is n(= nb*blockDim).</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="bsrValA">array of nnzb*blockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the non-zero blocks of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="csrValC">array of nnz (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnz column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in BSR format (that is defined by the three arrays
            bsrValA, bsrRowPtrA and bsrColIndA) into a sparse matrix in CSR format (that is
            defined by arrays csrValC, csrRowPtrC, and csrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A. The number of rows of sparse matrix C is m(= mb*blockDim).</param>
            <param name="nb">number of block columns of sparse matrix A. The number of columns of sparse matrix C is n(= nb*blockDim).</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="bsrValA">array of nnzb*blockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the non-zero blocks of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="csrValC">array of nnz (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnz column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in BSR format (that is defined by the three arrays
            bsrValA, bsrRowPtrA and bsrColIndA) into a sparse matrix in CSR format (that is
            defined by arrays csrValC, csrRowPtrC, and csrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A. The number of rows of sparse matrix C is m(= mb*blockDim).</param>
            <param name="nb">number of block columns of sparse matrix A. The number of columns of sparse matrix C is n(= nb*blockDim).</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="bsrValA">array of nnzb*blockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the non-zero blocks of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="csrValC">array of nnz (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnz column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in BSR format (that is defined by the three arrays
            bsrValA, bsrRowPtrA and bsrColIndA) into a sparse matrix in CSR format (that is
            defined by arrays csrValC, csrRowPtrC, and csrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A. The number of rows of sparse matrix C is m(= mb*blockDim).</param>
            <param name="nb">number of block columns of sparse matrix A. The number of columns of sparse matrix C is n(= nb*blockDim).</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="bsrValA">array of nnzb*blockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the non-zero blocks of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="csrValC">array of nnz (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnz column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebscBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in computing gebsr2gebsc.
            </summary>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="bsrVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb+1 elements that contains the
            start of every block row and the end of the last
            block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <returns>number of bytes of the buffer used in the gebsr2gebsc.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebscBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in computing gebsr2gebsc.
            </summary>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="bsrVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb+1 elements that contains the
            start of every block row and the end of the last
            block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <returns>number of bytes of the buffer used in the gebsr2gebsc.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebscBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in computing gebsr2gebsc.
            </summary>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="bsrVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb+1 elements that contains the
            start of every block row and the end of the last
            block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <returns>number of bytes of the buffer used in the gebsr2gebsc.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebscBufferSize(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in computing gebsr2gebsc.
            </summary>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="bsrVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb+1 elements that contains the
            start of every block row and the end of the last
            block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <returns>number of bytes of the buffer used in the gebsr2gebsc.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsrBufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32)">
            <summary>
            This function returns the size of the buffer used in computing csr2gebsrNnz and csr2gebsr.
            </summary>
            <param name="dir">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A.</param>
            <param name="csrColInd">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <returns>number of bytes of the buffer used in csr2gebsrNnz() and csr2gebsr().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsrBufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32)">
            <summary>
            This function returns the size of the buffer used in computing csr2gebsrNnz and csr2gebsr.
            </summary>
            <param name="dir">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A.</param>
            <param name="csrColInd">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <returns>number of bytes of the buffer used in csr2gebsrNnz() and csr2gebsr().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsrBufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32)">
            <summary>
            This function returns the size of the buffer used in computing csr2gebsrNnz and csr2gebsr.
            </summary>
            <param name="dir">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A.</param>
            <param name="csrColInd">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <returns>number of bytes of the buffer used in csr2gebsrNnz() and csr2gebsr().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsrBufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32)">
            <summary>
            This function returns the size of the buffer used in computing csr2gebsrNnz and csr2gebsr.
            </summary>
            <param name="dir">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A.</param>
            <param name="csrColInd">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <returns>number of bytes of the buffer used in csr2gebsrNnz() and csr2gebsr().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsrBufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in computing gebsr2gebsrNnz and gebsr2gebsr.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb*rowBlockDimA*colBlockDimA non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="rowBlockDimC">number of rows within a block of C.</param>
            <param name="colBlockDimC">number of columns within a block of C.</param>
            <returns>number of bytes of the buffer used in csr2gebsrNnz() and csr2gebsr().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsrBufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in computing gebsr2gebsrNnz and gebsr2gebsr.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb*rowBlockDimA*colBlockDimA non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="rowBlockDimC">number of rows within a block of C.</param>
            <param name="colBlockDimC">number of columns within a block of C.</param>
            <returns>number of bytes of the buffer used in csr2gebsrNnz() and csr2gebsr().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsrBufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in computing gebsr2gebsrNnz and gebsr2gebsr.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb*rowBlockDimA*colBlockDimA non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="rowBlockDimC">number of rows within a block of C.</param>
            <param name="colBlockDimC">number of columns within a block of C.</param>
            <returns>number of bytes of the buffer used in csr2gebsrNnz() and csr2gebsr().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsrBufferSize(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            This function returns size of buffer used in computing gebsr2gebsrNnz and gebsr2gebsr.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.
            Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb*rowBlockDimA*colBlockDimA non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="rowBlockDimC">number of rows within a block of C.</param>
            <param name="colBlockDimC">number of columns within a block of C.</param>
            <returns>number of bytes of the buffer used in csr2gebsrNnz() and csr2gebsr().</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsc(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function can be seen as the same as csr2csc when regarding each block of size
            rowBlockDim*colBlockDim as a scalar.<para/>
            This sparsity pattern of result matrix can also be seen as the transpose of the original
            sparse matrix but memory layout of a block does not change.<para/>
            The user must know the size of buffer required by gebsr2gebsc by calling
            gebsr2gebsc_bufferSizeExt, allocate the buffer and pass the buffer pointer to gebsr2gebsc.
            </summary>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb+1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="bscVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A. It is only filled-in if copyValues is set to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="bscRowInd">integer array of nnzb row indices of the non-zero blocks of matrix A</param>
            <param name="bscColPtr">integer array of nb+1 elements that contains the start of every block column and the end of the last block column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="baseIdx">CUSPARSE_INDEX_BASE_ZERO or CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsc_bufferSizeExt.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsc(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function can be seen as the same as csr2csc when regarding each block of size
            rowBlockDim*colBlockDim as a scalar.<para/>
            This sparsity pattern of result matrix can also be seen as the transpose of the original
            sparse matrix but memory layout of a block does not change.<para/>
            The user must know the size of buffer required by gebsr2gebsc by calling
            gebsr2gebsc_bufferSizeExt, allocate the buffer and pass the buffer pointer to gebsr2gebsc.
            </summary>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb+1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="bscVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A. It is only filled-in if copyValues is set to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="bscRowInd">integer array of nnzb row indices of the non-zero blocks of matrix A</param>
            <param name="bscColPtr">integer array of nb+1 elements that contains the start of every block column and the end of the last block column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="baseIdx">CUSPARSE_INDEX_BASE_ZERO or CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsc_bufferSizeExt.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsc(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function can be seen as the same as csr2csc when regarding each block of size
            rowBlockDim*colBlockDim as a scalar.<para/>
            This sparsity pattern of result matrix can also be seen as the transpose of the original
            sparse matrix but memory layout of a block does not change.<para/>
            The user must know the size of buffer required by gebsr2gebsc by calling
            gebsr2gebsc_bufferSizeExt, allocate the buffer and pass the buffer pointer to gebsr2gebsc.
            </summary>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb+1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="bscVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A. It is only filled-in if copyValues is set to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="bscRowInd">integer array of nnzb row indices of the non-zero blocks of matrix A</param>
            <param name="bscColPtr">integer array of nb+1 elements that contains the start of every block column and the end of the last block column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="baseIdx">CUSPARSE_INDEX_BASE_ZERO or CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsc_bufferSizeExt.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsc(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function can be seen as the same as csr2csc when regarding each block of size
            rowBlockDim*colBlockDim as a scalar.<para/>
            This sparsity pattern of result matrix can also be seen as the transpose of the original
            sparse matrix but memory layout of a block does not change.<para/>
            The user must know the size of buffer required by gebsr2gebsc by calling
            gebsr2gebsc_bufferSizeExt, allocate the buffer and pass the buffer pointer to gebsr2gebsc.
            </summary>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtr">integer array of mb+1 elements that contains the start of every block row and the end of the last block row plus one.</param>
            <param name="bsrColInd">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="bscVal">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A. It is only filled-in if copyValues is set to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="bscRowInd">integer array of nnzb row indices of the non-zero blocks of matrix A</param>
            <param name="bscColPtr">integer array of nb+1 elements that contains the start of every block column and the end of the last block column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="baseIdx">CUSPARSE_INDEX_BASE_ZERO or CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsc_bufferSizeExt.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in CSR format
            (that is defined by arrays csrValC, csrRowPtrC, and csrColIndC).<para/>
            Let m(=mb*rowBlockDim) be number of rows of A and n(=nb*colBlockDim) be
            number of columns of A, then A and C are m*n sparse matrices. General BSR format of
            A contains nnzb(=bsrRowPtrA[mb] - bsrRowPtrA[0]) non-zero blocks whereas
            sparse matrix A contains nnz(=nnzb*rowBlockDim*colBockDim) elements. The user
            must allocate enough space for arrays csrRowPtrC, csrColIndC and csrValC. The
            requirements are<para/>
            csrRowPtrC of m+1 elements,<para/>
            csrValC of nnz elements, and<para/>
            csrColIndC of nnz elements.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrC">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix C.</param>
            <param name="csrColIndC">integer array of nnz column indices of the nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in CSR format
            (that is defined by arrays csrValC, csrRowPtrC, and csrColIndC).<para/>
            Let m(=mb*rowBlockDim) be number of rows of A and n(=nb*colBlockDim) be
            number of columns of A, then A and C are m*n sparse matrices. General BSR format of
            A contains nnzb(=bsrRowPtrA[mb] - bsrRowPtrA[0]) non-zero blocks whereas
            sparse matrix A contains nnz(=nnzb*rowBlockDim*colBockDim) elements. The user
            must allocate enough space for arrays csrRowPtrC, csrColIndC and csrValC. The
            requirements are<para/>
            csrRowPtrC of m+1 elements,<para/>
            csrValC of nnz elements, and<para/>
            csrColIndC of nnz elements.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValC">array of nnz non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix C.</param>
            <param name="csrColIndC">integer array of nnz column indices of the nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in CSR format
            (that is defined by arrays csrValC, csrRowPtrC, and csrColIndC).<para/>
            Let m(=mb*rowBlockDim) be number of rows of A and n(=nb*colBlockDim) be
            number of columns of A, then A and C are m*n sparse matrices. General BSR format of
            A contains nnzb(=bsrRowPtrA[mb] - bsrRowPtrA[0]) non-zero blocks whereas
            sparse matrix A contains nnz(=nnzb*rowBlockDim*colBockDim) elements. The user
            must allocate enough space for arrays csrRowPtrC, csrColIndC and csrValC. The
            requirements are<para/>
            csrRowPtrC of m+1 elements,<para/>
            csrValC of nnz elements, and<para/>
            csrColIndC of nnz elements.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValC">array of nnz non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix C.</param>
            <param name="csrColIndC">integer array of nnz column indices of the nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in CSR format
            (that is defined by arrays csrValC, csrRowPtrC, and csrColIndC).<para/>
            Let m(=mb*rowBlockDim) be number of rows of A and n(=nb*colBlockDim) be
            number of columns of A, then A and C are m*n sparse matrices. General BSR format of
            A contains nnzb(=bsrRowPtrA[mb] - bsrRowPtrA[0]) non-zero blocks whereas
            sparse matrix A contains nnz(=nnzb*rowBlockDim*colBockDim) elements. The user
            must allocate enough space for arrays csrRowPtrC, csrColIndC and csrValC. The
            requirements are<para/>
            csrRowPtrC of m+1 elements,<para/>
            csrValC of nnz elements, and<para/>
            csrColIndC of nnz elements.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValC">array of nnz non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix C.</param>
            <param name="csrColIndC">integer array of nnz column indices of the nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in CSR format
            (that is defined by arrays csrValC, csrRowPtrC, and csrColIndC).<para/>
            Let m(=mb*rowBlockDim) be number of rows of A and n(=nb*colBlockDim) be
            number of columns of A, then A and C are m*n sparse matrices. General BSR format of
            A contains nnzb(=bsrRowPtrA[mb] - bsrRowPtrA[0]) non-zero blocks whereas
            sparse matrix A contains nnz(=nnzb*rowBlockDim*colBockDim) elements. The user
            must allocate enough space for arrays csrRowPtrC, csrColIndC and csrValC. The
            requirements are<para/>
            csrRowPtrC of m+1 elements,<para/>
            csrValC of nnz elements, and<para/>
            csrColIndC of nnz elements.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb*rowBlockDim*colBlockDim non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDim">number of rows within a block of A.</param>
            <param name="colBlockDim">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValC">array of nnz non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix C.</param>
            <param name="csrColIndC">integer array of nnz column indices of the nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsrNnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix A in CSR format (that is defined by arrays
            csrValA, csrRowPtrA, and csrColIndA) into a sparse matrix C in general BSR format
            (that is defined by the three arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A</param>
            <param name="csrColIndA">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <param name="nnzTotalDevHostPtr">total number of nonzero blocks of matrix C. <para/>
            Pointer nnzTotalDevHostPtr can point to a device memory or host memory.</param>
            <param name="buffer">buffer allocated by the user, the size is return by csr2gebsr_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsrNnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,System.Int32@,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix A in CSR format (that is defined by arrays
            csrValA, csrRowPtrA, and csrColIndA) into a sparse matrix C in general BSR format
            (that is defined by the three arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A</param>
            <param name="csrColIndA">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <param name="nnzTotalDevHostPtr">total number of nonzero blocks of matrix C. <para/>
            Pointer nnzTotalDevHostPtr can point to a device memory or host memory.</param>
            <param name="buffer">buffer allocated by the user, the size is return by csr2gebsr_bufferSizeExt().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix A in CSR format (that is defined by arrays
            csrValA, csrRowPtrA, and csrColIndA) into a sparse matrix C in general BSR format
            (that is defined by the three arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A</param>
            <param name="csrColIndA">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <param name="bsrColIndC"><para/>
            Pointer nnzTotalDevHostPtr can point to a device memory or host memory.</param>
            <param name="buffer">buffer allocated by the user, the size is return by csr2gebsr_bufferSizeExt().</param>
            <param name="csrValA">array of nnz nonzero elements of matrix A.</param>
            <param name="bsrValC">array of nnzb*rowBlockDim*colBlockDim nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix A in CSR format (that is defined by arrays
            csrValA, csrRowPtrA, and csrColIndA) into a sparse matrix C in general BSR format
            (that is defined by the three arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A</param>
            <param name="csrColIndA">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <param name="bsrColIndC"><para/>
            Pointer nnzTotalDevHostPtr can point to a device memory or host memory.</param>
            <param name="buffer">buffer allocated by the user, the size is return by csr2gebsr_bufferSizeExt().</param>
            <param name="csrValA">array of nnz nonzero elements of matrix A.</param>
            <param name="bsrValC">array of nnzb*rowBlockDim*colBlockDim nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix A in CSR format (that is defined by arrays
            csrValA, csrRowPtrA, and csrColIndA) into a sparse matrix C in general BSR format
            (that is defined by the three arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A</param>
            <param name="csrColIndA">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <param name="bsrColIndC"><para/>
            Pointer nnzTotalDevHostPtr can point to a device memory or host memory.</param>
            <param name="buffer">buffer allocated by the user, the size is return by csr2gebsr_bufferSizeExt().</param>
            <param name="csrValA">array of nnz nonzero elements of matrix A.</param>
            <param name="bsrValC">array of nnzb*rowBlockDim*colBlockDim nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2gebsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix A in CSR format (that is defined by arrays
            csrValA, csrRowPtrA, and csrColIndA) into a sparse matrix C in general BSR format
            (that is defined by the three arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the
            start of every row and the end of the last row plus one of matrix A</param>
            <param name="csrColIndA">integer array of nnz column indices of the nonzero elements of matrix A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="rowBlockDim">number of rows within a block of C.</param>
            <param name="colBlockDim">number of columns within a block of C.</param>
            <param name="bsrColIndC"><para/>
            Pointer nnzTotalDevHostPtr can point to a device memory or host memory.</param>
            <param name="buffer">buffer allocated by the user, the size is return by csr2gebsr_bufferSizeExt().</param>
            <param name="csrValA">array of nnz nonzero elements of matrix A.</param>
            <param name="bsrValC">array of nnzb*rowBlockDim*colBlockDim nonzero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsrNnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in another general
            BSR format (that is defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mc+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="rowBlockDimC">number of rows within a block of C</param>
            <param name="colBlockDimC">number of columns within a block of C</param>
            <param name="nnzTotalDevHostPtr">total number of nonzero blocks of C.<para/>
            nnzTotalDevHostPtr is the same as bsrRowPtrC[mc]-bsrRowPtrC[0]</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsr_bufferSizeExt.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsrNnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,System.Int32@,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in another general
            BSR format (that is defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mc+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="rowBlockDimC">number of rows within a block of C</param>
            <param name="colBlockDimC">number of columns within a block of C</param>
            <param name="nnzTotalDevHostPtr">total number of nonzero blocks of C.<para/>
            nnzTotalDevHostPtr is the same as bsrRowPtrC[mc]-bsrRowPtrC[0]</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsr_bufferSizeExt.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in another general
            BSR format (that is defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mc+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="bsrColIndC">integer array of nnzc block column indices of the non-zero blocks of matrix C.</param>
            <param name="rowBlockDimC">number of rows within a block of C</param>
            <param name="colBlockDimC">number of columns within a block of C</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsr_bufferSizeExt.</param>
            <param name="bsrValA">array of nnzb*rowBlockDimA*colBlockDimA non-zero elements of matrix A.</param>
            <param name="bsrValC">array of nnzc*rowBlockDimC*colBlockDimC non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in another general
            BSR format (that is defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mc+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="bsrColIndC">integer array of nnzc block column indices of the non-zero blocks of matrix C.</param>
            <param name="rowBlockDimC">number of rows within a block of C</param>
            <param name="colBlockDimC">number of columns within a block of C</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsr_bufferSizeExt.</param>
            <param name="bsrValA">array of nnzb*rowBlockDimA*colBlockDimA non-zero elements of matrix A.</param>
            <param name="bsrValC">array of nnzc*rowBlockDimC*colBlockDimC non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in another general
            BSR format (that is defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mc+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="bsrColIndC">integer array of nnzc block column indices of the non-zero blocks of matrix C.</param>
            <param name="rowBlockDimC">number of rows within a block of C</param>
            <param name="colBlockDimC">number of columns within a block of C</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsr_bufferSizeExt.</param>
            <param name="bsrValA">array of nnzb*rowBlockDimA*colBlockDimA non-zero elements of matrix A.</param>
            <param name="bsrValC">array of nnzc*rowBlockDimC*colBlockDimC non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gebsr2gebsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function converts a sparse matrix in general BSR format (that is defined by the three
            arrays bsrValA, bsrRowPtrA, and bsrColIndA) into a sparse matrix in another general
            BSR format (that is defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A.</param>
            <param name="nb">number of block columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="nnzb">number of nonzero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix A.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the nonzero blocks of matrix A.</param>
            <param name="rowBlockDimA">number of rows within a block of A.</param>
            <param name="colBlockDimA">number of columns within a block of A.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix 
            type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are
            CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrRowPtrC">integer array of mc+1 elements that contains the
            start of every block row and the end of the last block row plus one of matrix C.</param>
            <param name="bsrColIndC">integer array of nnzc block column indices of the non-zero blocks of matrix C.</param>
            <param name="rowBlockDimC">number of rows within a block of C</param>
            <param name="colBlockDimC">number of columns within a block of C</param>
            <param name="buffer">buffer allocated by the user, the size is return by gebsr2gebsr_bufferSizeExt.</param>
            <param name="bsrValA">array of nnzb*rowBlockDimA*colBlockDimA non-zero elements of matrix A.</param>
            <param name="bsrValC">array of nnzc*rowBlockDimC*colBlockDimC non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Single,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Double,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CreateIdentityPermutation(System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function creates an identity map. The output parameter p represents such map by p = 0:1:(n-1).<para/>
            This function is typically used with coosort, csrsort, cscsort, csr2csc_indexOnly.
            </summary>
            <param name="n">size of the map.</param>
            <param name="p">integer array of dimensions n.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CoosortBufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function sorts COO format. The stable sorting is in-place. Also the user can sort by row or sort by column.<para/>
            A is an m x n sparse matrix that is defined in COO storage format by the three arrays cooVals, cooRows, and cooCols.<para/>
            The matrix must be base 0.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="cooRowsA">integer array of nnz unsorted row indices of A.</param>
            <param name="cooColsA">integer array of nnz unsorted column indices of A.</param>
            <returns>number of bytes of the buffer.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CoosortByRow(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function sorts COO format. The stable sorting is in-place. Also the user can sort by row or sort by column.<para/>
            A is an m x n sparse matrix that is defined in COO storage format by the three arrays cooVals, cooRows, and cooCols.<para/>
            The matrix must be base 0.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="cooRowsA">integer array of nnz unsorted row indices of A.</param>
            <param name="cooColsA">integer array of nnz unsorted column indices of A.</param>
            <param name="P">integer array of nnz sorted map indices.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by CoosortBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CoosortByColumn(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function sorts COO format. The stable sorting is in-place. Also the user can sort by row or sort by column.<para/>
            A is an m x n sparse matrix that is defined in COO storage format by the three arrays cooVals, cooRows, and cooCols.<para/>
            The matrix must be base 0.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="cooRowsA">integer array of nnz unsorted row indices of A.</param>
            <param name="cooColsA">integer array of nnz unsorted column indices of A.</param>
            <param name="P">integer array of nnz sorted map indices.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by CoosortBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsortBufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function sorts CSR format. The stable sorting is in-place.<para/>
            The matrix type is regarded as CUSPARSE_MATRIX_TYPE_GENERAL implicitly. In other
            words, any symmetric property is ignored.<para/>
            This function csrsort() requires buffer size returned by csrsort_bufferSizeExt().<para/>
            The address of pBuffer must be multiple of 128 bytes. If not,
            CUSPARSE_STATUS_INVALID_VALUE is returned.<para/>
            The parameter P is both input and output. If the user wants to compute sorted csrVal,
            P must be set as 0:1:(nnz-1) before csrsort(), and after csrsort(), new sorted value
            array satisfies csrVal_sorted = csrVal(P).
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz unsorted column indices of A.</param>
            <returns>number of bytes of the buffer.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrsort(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function sorts CSR format. The stable sorting is in-place.<para/>
            The matrix type is regarded as CUSPARSE_MATRIX_TYPE_GENERAL implicitly. In other
            words, any symmetric property is ignored.<para/>
            This function csrsort() requires buffer size returned by csrsort_bufferSizeExt().<para/>
            The address of pBuffer must be multiple of 128 bytes. If not,
            CUSPARSE_STATUS_INVALID_VALUE is returned.<para/>
            The parameter P is both input and output. If the user wants to compute sorted csrVal,
            P must be set as 0:1:(nnz-1) before csrsort(), and after csrsort(), new sorted value
            array satisfies csrVal_sorted = csrVal(P).
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz unsorted column indices of A.</param>
            <param name="P">integer array of nnz sorted map indices.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by CsrsortBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CscsortBufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function sorts CSC format. The stable sorting is in-place.<para/>
            The matrix type is regarded as CUSPARSE_MATRIX_TYPE_GENERAL implicitly. In other
            words, any symmetric property is ignored. <para/>
            This function cscsort() requires buffer size returned by cscsort_bufferSizeExt().
            The address of pBuffer must be multiple of 128 bytes. If not,
            CUSPARSE_STATUS_INVALID_VALUE is returned.<para/>
            The parameter P is both input and output. If the user wants to compute sorted cscVal,
            P must be set as 0:1:(nnz-1) before cscsort(), and after cscsort(), new sorted value
            array satisfies cscVal_sorted = cscVal(P).
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="cscRowIndA">integer array of nnz unsorted row indices of A.</param>
            <returns>number of bytes of the buffer.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Cscsort(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function sorts CSC format. The stable sorting is in-place.<para/>
            The matrix type is regarded as CUSPARSE_MATRIX_TYPE_GENERAL implicitly. In other
            words, any symmetric property is ignored. <para/>
            This function cscsort() requires buffer size returned by cscsort_bufferSizeExt().
            The address of pBuffer must be multiple of 128 bytes. If not,
            CUSPARSE_STATUS_INVALID_VALUE is returned.<para/>
            The parameter P is both input and output. If the user wants to compute sorted cscVal,
            P must be set as 0:1:(nnz-1) before cscsort(), and after cscsort(), new sorted value
            array satisfies cscVal_sorted = cscVal(P).
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="cscRowIndA">integer array of nnz unsorted row indices of A.</param>
            <param name="P">integer array of nnz sorted map indices.</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by CscsortBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csru2csrBufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo)">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <returns>number of bytes of the buffer.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csru2csrBufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo)">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <returns>number of bytes of the buffer.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csru2csrBufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo)">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <returns>number of bytes of the buffer.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csru2csrBufferSize(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo)">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <returns>number of bytes of the buffer.</returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csru2csr(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL, Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by Csru2csrBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csru2csr(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL, Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by Csru2csrBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csru2csr(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL, Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by Csru2csrBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csru2csr(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL, Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by Csru2csrBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csru(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL, Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by Csru2csrBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csru(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL, Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by Csru2csrBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csru(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL, Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by Csru2csrBufferSize().</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csru(System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo,ManagedCuda.CudaDeviceVariable{System.Byte})">
            <summary>
            This function transfers unsorted CSR format to CSR format, and vice versa. The operation is in-place.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="nnz">number of nonzero elements of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL, Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrVal">array of nnz unsorted nonzero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m+1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz unsorted column indices of A.</param>
            <param name="info">opaque structure initialized using cusparseCreateCsru2csrInfo().</param>
            <param name="pBuffer">buffer allocated by the user; the size is returned by Csru2csrBufferSize().</param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseContext.Handle">
            <summary>
            Returns the wrapped cusparseContext handle
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info">
            <summary>
            Wrapper class for csrgemm2Info
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseCsrgemm2Info.Csrgemm2Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo">
            <summary>
            Wrapper class for csru2csrInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseCsru2csrInfo.Csru2csrInfo">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseException">
            <summary>
            An CudaSparseException is thrown, if any wrapped call to the CUSPARSE-library does not return <see cref="F:ManagedCuda.CudaSparse.cusparseStatus.Success"/>.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="serInfo"></param>
            <param name="streamingContext"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(ManagedCuda.CudaSparse.cusparseStatus)">
            <summary>
            
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(ManagedCuda.CudaSparse.cusparseStatus,System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="error"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseException.CudaSparseError">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseHybMat">
            <summary>
            Wrapper class for cusparseHybMat handle
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseHybMat.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseHybMat.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseHybMat.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseHybMat.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseHybMat.HybMat">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor">
            <summary>
            Wrapper class for cusparseMatDescr handle.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.#ctor">
            <summary>
            When the matrix descriptor is created, its fields are initialized to: 
            CUSPARSE_MATRIXYPE_GENERAL
            CUSPARSE_INDEX_BASE_ZERO
            All other fields are uninitialized
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.#ctor(ManagedCuda.CudaSparse.cusparseFillMode,ManagedCuda.CudaSparse.cusparseDiagType)">
            <summary>
            When the matrix descriptor is created, its fields are initialized to: 
            CUSPARSE_MATRIXYPE_GENERAL
            CUSPARSE_INDEX_BASE_ZERO
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.#ctor(ManagedCuda.CudaSparse.cusparseMatrixType,ManagedCuda.CudaSparse.cusparseFillMode,ManagedCuda.CudaSparse.cusparseDiagType,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Creates a new CudaSparseMatrixDescriptor
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.SetMatType(ManagedCuda.CudaSparse.cusparseMatrixType)">
            <summary>
            Sets the matrix type
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.GetMatType">
            <summary>
            Returns matrix type
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.SetMatFillMode(ManagedCuda.CudaSparse.cusparseFillMode)">
            <summary>
            Sets matrix fill mode
            </summary>
            <param name="fillMode"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.GetMatFillMode">
            <summary>
            Returns matrix fill mode
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.SetMatDiagType(ManagedCuda.CudaSparse.cusparseDiagType)">
            <summary>
            Sets matrix diagonal type
            </summary>
            <param name="diagType"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.GetMatDiagType">
            <summary>
            Returns matrix diagonal type
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.SetMatIndexBase(ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Sets matrix index base
            </summary>
            <param name="indexBase"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.GetMatIndexBase">
            <summary>
            Returns matrix index base.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Copy">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Descriptor">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseNativeMethods">
            <summary>
            C# wrapper for cusparse.h
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreate(ManagedCuda.CudaSparse.cusparseContext@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroy(ManagedCuda.CudaSparse.cusparseContext)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetVersion(ManagedCuda.CudaSparse.cusparseContext,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetStream(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.BasicTypes.CUstream)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetStream(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.BasicTypes.CUstream@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetPointerMode(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparsePointerMode@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetPointerMode(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparsePointerMode)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateMatDescr(ManagedCuda.CudaSparse.cusparseMatDescr@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyMatDescr(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCopyMatDescr(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetMatType(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseMatrixType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetMatType(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetMatFillMode(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseFillMode)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetMatFillMode(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetMatDiagType(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseDiagType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetMatDiagType(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetMatIndexBase(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetMatIndexBase(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateSolveAnalysisInfo(ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroySolveAnalysisInfo(ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetLevelInfo(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr@,ManagedCuda.BasicTypes.CUdeviceptr@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateCsrsv2Info(ManagedCuda.CudaSparse.csrsv2Info@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyCsrsv2Info(ManagedCuda.CudaSparse.csrsv2Info)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateCsric02Info(ManagedCuda.CudaSparse.csric02Info@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyCsric02Info(ManagedCuda.CudaSparse.csric02Info)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateBsric02Info(ManagedCuda.CudaSparse.bsric02Info@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyBsric02Info(ManagedCuda.CudaSparse.bsric02Info)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateCsrilu02Info(ManagedCuda.CudaSparse.csrilu02Info@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyCsrilu02Info(ManagedCuda.CudaSparse.csrilu02Info)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateBsrilu02Info(ManagedCuda.CudaSparse.bsrilu02Info@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyBsrilu02Info(ManagedCuda.CudaSparse.bsrilu02Info)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateBsrsv2Info(ManagedCuda.CudaSparse.bsrsv2Info@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyBsrsv2Info(ManagedCuda.CudaSparse.bsrsv2Info)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateBsrsm2Info(ManagedCuda.CudaSparse.bsrsm2Info@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyBsrsm2Info(ManagedCuda.CudaSparse.bsrsm2Info)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateHybMat(ManagedCuda.CudaSparse.cusparseHybMat@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyHybMat(ManagedCuda.CudaSparse.cusparseHybMat)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateCsru2csrInfo(ManagedCuda.CudaSparse.csru2csrInfo@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyCsru2csrInfo(ManagedCuda.CudaSparse.csru2csrInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateColorInfo(ManagedCuda.CudaSparse.cusparseColorInfo@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyColorInfo(ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetColorAlgs(ManagedCuda.CudaSparse.cusparseColorInfo,ManagedCuda.CudaSparse.cusparseColorAlg)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetColorAlgs(ManagedCuda.CudaSparse.cusparseColorInfo,ManagedCuda.CudaSparse.cusparseColorAlg@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateCsrgemm2Info(ManagedCuda.CudaSparse.csrgemm2Info@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyCsrgemm2Info(ManagedCuda.CudaSparse.csrgemm2Info)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSaxpyi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDaxpyi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCaxpyi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZaxpyi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSaxpyi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDaxpyi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCaxpyi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZaxpyi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdotci(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdotci(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdotci(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdotci(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgthr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgthr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgthr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgthr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgthrz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgthrz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgthrz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgthrz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSsctr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDsctr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsctr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZsctr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSroti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,System.Single@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDroti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,System.Double@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSroti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDroti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsrmvEx_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseAlgMode,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsrmvEx(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseAlgMode,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmv_mp(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmv_mp(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmv_mp(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmv_mp(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsrmvEx_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseAlgMode,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsrmvEx(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseAlgMode,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmv_mp(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmv_mp(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmv_mp(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmv_mp(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgemvi(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgemvi_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgemvi(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgemvi_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgemvi(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgemvi_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgemvi(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgemvi_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgemvi(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgemvi(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgemvi(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgemvi(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsrsv_analysisEx(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.cudaDataType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsrsv_solveEx(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.IntPtr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsrsv_solveEx(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.cudaDataType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsv2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsv2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsv2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsv2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsv2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsv2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsv2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsv2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsv2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsv2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsv2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsv2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrsv2_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXbsrsv2_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrsv2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrsv2_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXbsrsv2_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsv2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsv2Info,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgemmi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgemmi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgemmi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgemmi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgemmi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgemmi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgemmi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgemmi(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmm2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmm2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmm2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmm2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmm2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmm2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmm2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/> 
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmm2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsm_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsm_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsm_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsm_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsm2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsm2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsm2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsm2_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsm2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsm2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsm2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsm2_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXbsrsm2_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrsm2Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsm2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsm2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsm2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsm2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXbsrsm2_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrmm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrsm2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrsm2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrsm2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrsm2_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrsm2Info,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsrilu0Ex(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.cudaDataType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrilu0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrilu0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrilu0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrilu0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32,System.Double@,System.Single@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32,System.Double@,System.Double@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrilu02_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,System.Double@,System.Single@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,System.Double@,System.Double@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuFloatComplex@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,System.Double@,ManagedCuda.VectorTypes.cuDoubleComplex@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXbsrilu02_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrilu02_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrilu02_numericBoost(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXbsrilu02_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrilu02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrilu02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrilu02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrilu02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrilu02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrilu02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrilu02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrilu02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrilu02_analysis(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrilu02_analysis(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrilu02_analysis(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrilu02_analysis(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrilu02(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrilu02(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrilu02(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrilu02(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrilu02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrilu02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrilu02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrilu02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrilu02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrilu02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrilu02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrilu02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrilu02_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrilu02_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrilu02_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrilu02_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrilu02(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrilu02(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrilu02(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrilu02(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsrilu02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsric0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsric0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsric0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsric0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsric02_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXbsric02_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsric02_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXbsric02_zeroPivot(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsric02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsric02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsric02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsric02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsric02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsric02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsric02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsric02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsric02_analysis(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsric02_analysis(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsric02_analysis(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsric02_analysis(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsric02(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsric02(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsric02(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsric02(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsric02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsric02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsric02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsric02_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsric02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsric02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsric02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsric02_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsric02_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsric02_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsric02_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsric02_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsric02(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsric02(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsric02(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsric02(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.bsric02Info,ManagedCuda.CudaSparse.cusparseSolvePolicy,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgtsv(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgtsv(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgtsv(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgtsv(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgtsv_nopivot(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgtsv_nopivot(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgtsv_nopivot(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgtsv_nopivot(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgtsvStridedBatch(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgtsvStridedBatch(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgtsvStridedBatch(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgtsvStridedBatch(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSnnz_compress(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDnnz_compress(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCnnz_compress(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZnnz_compress(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2csr_compress(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2csr_compress(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2csr_compress(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2csr_compress(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdense2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdense2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdense2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdense2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdense2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdense2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdense2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdense2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsc2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsc2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsc2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsc2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcoo2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsr2coo(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsr2cscEx(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.cudaDataType,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.cudaDataType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdense2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdense2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdense2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdense2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShyb2dense(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhyb2dense(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChyb2dense(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhyb2dense(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgemmNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgemmNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgemm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgemm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgemm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgemm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgemm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgemm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgemm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgemm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgemm2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgemm2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgemm2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgemm2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgemm2Nnz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgemm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgemm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgemm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgemm2_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgemm2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgemm2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgemm2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgemm2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgemm2Nnz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csrgemm2Info,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgeamNnz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgeamNnz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrcolor(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrcolor(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrcolor(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrcolor(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrcolor(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrcolor(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrcolor(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrcolor(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseColorInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShyb2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhyb2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChyb2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhyb2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsc2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsc2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsc2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsc2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShyb2csc(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhyb2csc(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChyb2csc(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhyb2csc(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsr2bsrNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsr2bsrNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2bsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2bsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2bsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2bsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgebsr2gebsc_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgebsr2gebsc_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgebsr2gebsc_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgebsr2gebsc_bufferSize(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgebsr2gebsc_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgebsr2gebsc_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgebsr2gebsc_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgebsr2gebsc_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgebsr2gebsc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgebsr2gebsc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgebsr2gebsc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgebsr2gebsc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXgebsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgebsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgebsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgebsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgebsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2gebsr_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2gebsr_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2gebsr_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2gebsr_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2gebsr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2gebsr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2gebsr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2gebsr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsr2gebsrNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsr2gebsrNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2gebsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2gebsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2gebsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2gebsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgebsr2gebsr_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgebsr2gebsr_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgebsr2gebsr_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgebsr2gebsr_bufferSize(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgebsr2gebsr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgebsr2gebsr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgebsr2gebsr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgebsr2gebsr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXgebsr2gebsrNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,System.Int32@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXgebsr2gebsrNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgebsr2gebsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgebsr2gebsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgebsr2gebsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgebsr2gebsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateIdentityPermutation(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcoosort_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcoosortByRow(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcoosortByColumn(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrsort_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrsort(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcscsort_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcscsort(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsru2csr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsru2csr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsru2csr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsru2csr_bufferSizeExt(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.SizeT@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsru2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsru2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsru2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsru2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2csru(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2csru(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2csru(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2csru(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.csru2csrInfo,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.SolveAnalysisInfo">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseStatus">
            <summary>
            This is a status type returned by the library functions and it can have the following values.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.Success">
            <summary>
            The operation completed successfully.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.NotInitialized">
            <summary>
            "The CUSPARSE library was not initialized. This is usually caused by the lack of a prior 
            cusparseCreate() call, an error in the CUDA Runtime API called by the CUSPARSE routine, or an 
            error in the hardware setup. To correct: call cusparseCreate() prior to the function call; and
             check that the hardware, an appropriate version of the driver, and the CUSPARSE library are 
            correctly installed.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.AllocFailed">
            <summary>
             "Resource allocation failed inside the CUSPARSE library. This is usually caused by a 
            cudaMalloc() failure. To correct: prior to the function call, deallocate previously allocated
            memory as much as possible.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.InvalidValue">
            <summary>
            "An unsupported value or parameter was passed to the function (a negative vector size, 
            for example). To correct: ensure that all the parameters being passed have valid values.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.ArchMismatch">
            <summary>
            "The function requires a feature absent from the device architecture; usually caused by 
            the lack of support for atomic operations or double precision. To correct: compile and run the
             application on a device with appropriate compute capability, which is 1.1 for 32-bit atomic 
            operations and 1.3 for double precision.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.MappingError">
            <summary>
            "An access to GPU memory space failed, which is usually caused by a failure to bind a texture. 
            To correct: prior to the function call, unbind any previously bound textures.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.ExecutionFailed">
            <summary>
            "The GPU program failed to execute. This is often caused by a launch failure of the kernel on 
            the GPU, which can be caused by multiple reasons. To correct: check that the hardware, an appropriate
             version of the driver, and the CUSPARSE library are correctly installed.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.InternalError">
            <summary>
            "An internal CUSPARSE operation failed. This error is usually caused by a cudaMemcpyAsync() 
            failure. To correct: check that the hardware, an appropriate version of the driver, and the CUSPARSE
             library are correctly installed. Also, check that the memory passed as a parameter to the routine 
            is not being deallocated prior to the routines completion.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.MatrixTypeNotSupported">
            <summary>
            "The matrix type is not supported by this function. This is usually caused by passing an invalid 
            matrix descriptor to the function. To correct: check that the fields in cusparseMatDescr_t descrA were 
            set correctly.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.ZeroPivot">
             <summary>
            
             </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparsePointerMode">
            <summary>
            This type indicates whether the scalar values are passed by reference on the host or device.
            It is important to point out that if several scalar values are passed by reference in the
            function call, all of them will conform to the same single pointer mode. The pointer mode
            can be set and retrieved using <see cref="M:ManagedCuda.CudaSparse.CudaSparseContext.SetPointerMode(ManagedCuda.CudaSparse.cusparsePointerMode)"/> and
            <see cref="M:ManagedCuda.CudaSparse.CudaSparseContext.GetPointerMode"/> routines, respectively.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparsePointerMode.Host">
            <summary>
            Use host pointers.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparsePointerMode.Device">
            <summary>
            Use device pointers.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseAction">
            <summary>
            This type indicates whether the operation is performed only on indices or on data and indices.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseAction.Symbolic">
            <summary>
            the operation is performed only on indices.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseAction.Numeric">
            <summary>
            the operation is performed on data and indices.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseMatrixType">
            <summary>
            This type indicates the type of matrix stored in sparse storage. Notice that for symmetric,
            Hermitian and triangular matrices only their lower or upper part is assumed to be stored.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatrixType.General">
            <summary>
            the matrix is general.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatrixType.Symmetric">
            <summary>
            the matrix is symmetric.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatrixType.Hermitian">
            <summary>
            the matrix is Hermitian.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatrixType.Triangular">
            <summary>
            the matrix is triangular.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseFillMode">
            <summary>
            This type indicates if the lower or upper part of a matrix is stored in sparse storage.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseFillMode.Lower">
            <summary>
            the lower triangular part is stored.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseFillMode.Upper">
            <summary>
            the upper triangular part is stored.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseDiagType">
            <summary>
            This type indicates if the matrix diagonal entries are unity. The diagonal elements are
            always assumed to be present, but if CUSPARSE_DIAG_TYPE_UNIT is passed to an API
            routine, then the routine will assume that all diagonal entries are unity and will not read
            or modify those entries. Note that in this case the routine assumes the diagonal entries are
            equal to one, regardless of what those entries are actuall set to in memory.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseDiagType.NonUnit">
            <summary>
            the matrix diagonal has non-unit elements.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseDiagType.Unit">
            <summary>
            the matrix diagonal has unit elements.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseIndexBase">
            <summary>
            This type indicates if the base of the matrix indices is zero or one.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseIndexBase.Zero">
            <summary>
            the base index is zero.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseIndexBase.One">
            <summary>
            the base index is one.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseOperation">
            <summary>
            This type indicates which operations need to be performed with the sparse matrix.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseOperation.NonTranspose">
            <summary>
            the non-transpose operation is selected.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseOperation.Transpose">
            <summary>
            the transpose operation is selected.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseOperation.ConjugateTranspose">
            <summary>
            the conjugate transpose operation is selected.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseDirection">
            <summary>
            This type indicates whether the elements of a dense matrix should be parsed by rows or by
            columns (assuming column-major storage in memory of the dense matrix).
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseDirection.Row">
            <summary>
            the matrix should be parsed by rows.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseDirection.Column">
            <summary>
            the matrix should be parsed by columns.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseHybPartition">
            <summary>
            This type indicates how to perform the partitioning of the matrix into regular (ELL) and
            irregular (COO) parts of the HYB format.<para/>
            The partitioning is performed during the conversion of the matrix from a dense or sparse
            format into the HYB format and is governed by the following rules. When
            CUSPARSE_HYB_PARTITION_AUTO is selected, the CUSPARSE library automatically decides
            how much data to put into the regular and irregular parts of the HYB format. When
            CUSPARSE_HYB_PARTITION_USER is selected, the width of the regular part of the HYB
            format should be specified by the caller. When CUSPARSE_HYB_PARTITION_MAX is selected,
            the width of the regular part of the HYB format equals to the maximum number of
            non-zero elements per row, in other words, the entire matrix is stored in the regular part of
            the HYB format.<para/>
            The default is to let the library automatically decide how to split the data.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseHybPartition.Auto">
            <summary>
            the automatic partitioning is selected (default).
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseHybPartition.User">
            <summary>
            the user specified treshold is used.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseHybPartition.Max">
            <summary>
            the data is stored in ELL format.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseSolvePolicy">
            <summary>
            used in csrsv2, csric02, and csrilu02
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseSolvePolicy.NoLevel">
            <summary>
            no level information is generated, only reports structural zero.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseSolvePolicy.UseLevel">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseSideMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseSideMode.Left">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseSideMode.Right">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseColorAlg">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseColorAlg.ALG0">
            <summary>
            default
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseColorAlg.ALG1">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseAlgMode">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseAlgMode.ALG0">
            <summary>
            default, naive
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseAlgMode.ALG1">
            <summary>
            merge path
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseContext">
            <summary>
            Opaque structure holding CUSPARSE library context
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseContext.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseMatDescr">
            <summary>
            Opaque structure holding the matrix descriptor
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatDescr.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.csrsv2Info">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.csrsv2Info.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.bsrsv2Info">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.bsrsv2Info.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.csric02Info">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.csric02Info.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.bsric02Info">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.bsric02Info.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.bsrsm2Info">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.bsrsm2Info.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.csrilu02Info">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.csrilu02Info.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.bsrilu02Info">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.bsrilu02Info.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseHybMat">
            <summary>
            Opaque structure holding the hybrid (HYB) storage information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseHybMat.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.csrgemm2Info">
            <summary>
            Opaque structure holding sparse gemm information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.csrgemm2Info.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.csru2csrInfo">
            <summary>
            Opaque structure holding the sorting information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.csru2csrInfo.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseColorInfo">
            <summary>
            Opaque structure holding the coloring information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseColorInfo.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseCsrsv2Info">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrsv2Info.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrsv2Info.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrsv2Info.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrsv2Info.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseCsrsv2Info.Csrsv2Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseCsric02Info">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsric02Info.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsric02Info.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsric02Info.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsric02Info.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseCsric02Info.Csric02Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseCsrilu02Info">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrilu02Info.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrilu02Info.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrilu02Info.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseCsrilu02Info.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseCsrilu02Info.Csrilu02Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseBsrilu02Info">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrilu02Info.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrilu02Info.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrilu02Info.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrilu02Info.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseBsrilu02Info.Bsrilu02Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseBsrsv2Info">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrsv2Info.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrsv2Info.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrsv2Info.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsrsv2Info.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseBsrsv2Info.Bsrsv2Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseBsric02Info">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsric02Info.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsric02Info.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsric02Info.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseBsric02Info.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseBsric02Info.Bsric02Info">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
    </members>
</doc>
